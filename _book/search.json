[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zbiór zadań - Java",
    "section": "",
    "text": "Zbiór zadań - Java\nTu będzie zbiór zadań z programowania w języku Java. Inspiracją było zebranie zadań powstałych w trakcie prowadzenia zajęć dydaktycznych realizowanych na Wydziale Matematyki i Informatyki Uniwersytetu Warmińsko-Mazurskiego w Olsztynie.\nZmiany:\n10.10.2023 - uzupełniono zadania dot tablic, list tablicowych, napisów\n\n\n\n\nKozak, Jan. b.d. Materiały do ćwiczeń. Dostęp 16 lipiec 2023. http://www.jkozak.pl/przedmioty/podstawy-i-jezyki-programowania/materialy-do-cwiczen/.\n\n\nRychlicki, Wiesław. 2012. Programowanie w języku Java. Zbiór zadań z (p)odpowiedziami. Helion."
  },
  {
    "objectID": "wejsciewyjscie.html",
    "href": "wejsciewyjscie.html",
    "title": "1  Operacje wejścia/wyjścia",
    "section": "",
    "text": "Napisz prostą aplikację kalkulatora tekstowego, która przyjmuje dwa liczby od użytkownika jako wejście i wykonuje podstawowe operacje matematyczne (dodawanie, odejmowanie, mnożenie, dzielenie). Wyświetl wyniki na ekranie.\nNapisz program, który wczytuje ze standardowego wejścia dwa łańcuchy znaków, a następnie wypisuje je w kolejnych wierszach na standardowym wyjściu.\nNapisz program, który wczytuje ze standardowego wejścia cztery liczby wymierne, a następnie wypisuje ich sumę na standardowym wyjściu.\nStwórz program do obliczenia pola kwadratu. Dane pobierz od użytkownika, wynik wyświetl na standardowym wyjściu.\nNapisz program, w którym wartości zmiennych pobierasz od użytkownika i wykonasz i wyświetlisz wyniki operacji:\n\n\n\\(a+b-x^2\\)\n\\(\\frac{a-b}{c-3}\\)\n\\(3(4+5a)(b-c^3)\\)\n\n\nNapisz program, w którym zostaną wykonane poniższe operacje za pomocą tzw. złożonych operatorów przypisania (+= , -= i innych podobnych operatorów):\n\n\n\\(a=a+4\\)\n\\(b=b-a\\)\n\\(c=c(2-4a)\\)\n\\(d=\\frac{d}{4-a^2}\\)"
  },
  {
    "objectID": "instrukcjewarunkowe.html",
    "href": "instrukcjewarunkowe.html",
    "title": "2  Instrukcje warunkowe",
    "section": "",
    "text": "Napisz program, który sprawdza, czy podana liczba całkowita jest parzysta. Jeżeli tak, program powinien wypisać “Liczba jest parzysta”, w przeciwnym razie “Liczba jest nieparzysta”.\nNapisz program, który przyjmuje trzy liczby całkowite jako argumenty i zwraca największą z nich. Zastosuj instrukcje warunkowe do porównania liczb.\nNapisz program, który na podstawie podanego jako argument numeru dnia tygodnia (od 1 do 7) wypisze nazwę tego dnia tygodnia. Dla przykładu, jeżeli użytkownik poda liczbę 1, program powinien wypisać “Poniedziałek”. Jeżeli podana liczba nie jest z zakresu od 1 do 7, program powinien wyświetlić komunikat “Niepoprawny numer dnia tygodnia”.\nNapisz program, który rozwiązuje równanie kwadratowe o postaci \\(ax^2 + bx + c = 0\\). Program powinien przyjmować jako argumenty wartości \\(a\\), \\(b\\), i \\(c\\), obliczać delty (\\(b^2 - 4ac\\)), a następnie zwracać rozwiązania równania w zależności od wartości delty.\nNapisz program, który przyjmuje wiek użytkownika jako argument. Jeżeli wiek jest mniejszy niż 18, program powinien wyświetlić “Jesteś niepełnoletni”. Jeżeli wiek jest większy lub równy 18, ale mniejszy od 65, program powinien wyświetlić “Jesteś dorosły”. Jeżeli wiek jest równy lub większy niż 65, program powinien wyświetlić “Jesteś emerytem”.\nNapisz program, który będzie sprawdzał, czy podany rok jest rokiem przestępnym. Rok jest przestępny, jeśli jest podzielny przez 4, ale nie jest podzielny przez 100, chyba że jest podzielny przez 400.\nNapisz program, który przyjmuje trzy liczby całkowite jako argumenty i sortuje je w kolejności rosnącej, używając instrukcji warunkowych, a następnie wyświetla posortowane liczby.\nNapisz program, który oblicza podatek dochodowy na podstawie podanych dochodów i zasad podatkowych. Załóżmy, że podatek wynosi 18% dla dochodu do 85,528 PLN, a dla dochodu powyżej tej kwoty podatek wynosi 14,839.02 PLN plus 32% nadwyżki ponad 85,528 PLN. Użytkownik powinien wprowadzić swoje dochody, a program powinien obliczyć i wyświetlić kwotę podatku.\nNapisz program sprawdzający czy podane liczby z klawiatury mogą stanowić poprawną datę w kalendarzu.\n\nPrzykładowe wejście:\nPodaj dzień: 29\nPodaj miesiąc: 2\nPodaj rok: 2017\nPrzykładowe wyjście:\nBłędna data\n\nNapisz program sprawdzający czy podane liczby z klawiatury mogą stanowić poprawna godzinę w formacie 24-godzinnym.\n\nPrzykładowe wejście:\nPodaj godzinę: 22\nPodaj minuty: 12\nPodaj sekundy: 33\nPrzykładowe wyjście:\nPoprawna godzina!\n\nNapisz program, w którym użytkownik ma wprowadzić trzycyfrową liczbę całkowitą. Następnie należy sprawdzić czy liczba jest palindromem. Stosowny komunikat wyświetl na konsoli.\nNapisz program, który pobiera trzy liczby całkowite (teoretycznie mogą być różnych znaków) i sprawdza, czy można z nich zbudować trójkąt prostokątny - ostatecznie wypisuje „TAK” lub „NIE”."
  },
  {
    "objectID": "petle.html",
    "href": "petle.html",
    "title": "3  Pętle",
    "section": "",
    "text": "Napisz program, który wykorzystując pętlę for wyświetli liczby od 1 do 100.\nNapisz program, który przy użyciu pętli while obliczy sumę liczb od 1 do 50.\nNapisz program w Javie, który za pomocą pętli for generuje pierwsze 10 liczb ciągu Fibonacciego.\nStwórz program, który używając zagnieżdżonych pętli for, wyświetli tabliczkę mnożenia dla liczb od 1 do 10.\nNapisz program, który używając pętli do-while, wyświetli pierwsze 20 liczb parzystych i nieparzystych.\nNapisz program, który sprawdzi, czy podana liczba jest liczbą pierwszą. Liczba powinna być wprowadzona przez użytkownika.\nNapisz program, który oblicza sumę cyfr dowolnej wprowadzonej liczby. Program powinien akceptować liczbę jako input od użytkownika.\nNapisz program, który generuje i wyświetla pierwsze 10 elementów szeregu geometrycznego o zadanym pierwszym elemencie i ilorazie. Parametry szeregu powinny być wprowadzane przez użytkownika.\nStwórz program, który przyjmie od użytkownika liczbę całkowitą i zwróci tę liczbę w odwrotnej kolejności. Na przykład, dla liczby 12345, wynik powinien wynosić 54321. Możesz ograniczyć program tylko do liczb dodatnich.\nNapisz program, który obliczy sumę kwadratów liczb od 1 do n, gdzie n jest liczbą wprowadzoną przez użytkownika.\nNapisz program, który znajdzie i wyświetli wszystkie liczby doskonałe mniejsze od 10 000. Liczba doskonała to taka, której suma dzielników (bez niej samej) jest równa jej wartości. Na przykład, 6 jest liczbą doskonałą, ponieważ \\(1 + 2 + 3 = 6\\).\nNapisz program, który znajdzie wszystkie liczby Amstronga mniejsze od 10 000. Liczba Amstronga to taka, której suma jej cyfr podniesionych do potęgi równiej liczbie cyfr w tej liczbie, jest równa samej liczbie. Na przykład 153 jest liczbą Amstronga, ponieważ \\(1^3 + 5^3 + 3^3 = 153\\).\nNapisz program, który dla dwóch podanych liczb obliczy ich najmniejszą wspólną wielokrotność (NWW). Użytkownik powinien podać dwie liczby jako dane wejściowe.\nNapisz program pobierający z klawiatury liczbę całkowitą dodatnią. Następnie narysuj odpowiedni trójkąt np. dla 5:\n\n1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n\nNapisz program, który pobiera od użytkownika liczbę naturalną \\(n\\) (\\(n\\geqslant 0\\)). Następnie wyznacz i wyświetl \\(n\\)-ty element ciągu:\n\n\n\n\\((4,-8,16,-32,64,\\ldots )\\)\n\\((2,6,18,54,162,\\ldots )\\)\n\\((8,3,-2,-7,-12,\\ldots )\\)\n\n\n\nNapisz program wczytujący kolejne liczby całkowite (różnych znaków) z klawiatury i kończący się gdy ich suma przekroczy 100.\nNapisz program, który pobiera od użytkownika dodatnią liczbę całkowitą \\(n\\), następnie \\(n\\) liczb całkowitych \\(a_1, \\ldots, a_n\\). Program ma wyświetlić ile spośród tych liczb spełnia warunek \\(3^k &lt; a_k &lt;k!\\) dla \\(1\\leq k \\leq n\\).\nNapisać program wyświetlający na ekranie pierwsze szesnaście potęg dwójki. Wykorzystaj w tym celu pętle.\nNapisz program, który pobiera od użytkownika 5 liczb całkowitych. Pobieranie ma zostać przerwane, gdy użytkownik wprowadzić liczbę ujemną. Jeśli pobieranie nie zostanie przerwane, wyświetl sumę wprowadzonych liczb.\nNapisz program, który wczytuje ze standardowego wejścia dwie liczby całkowite \\(n\\) i \\(m\\) (zakładamy, że \\(n &lt; m\\)) i wypisuje na standardowym wyjściu wartość liczby \\(n\\cdot \\ldots \\cdot m\\).\nNapisz program, który wczytuje ze standardowego wejścia dwie liczby całkowite \\(n\\) i \\(m\\) (zakładamy, że \\(n &lt; m\\)) i wypisuje na standardowym wyjściu wartość liczby \\(n+ \\ldots + m\\).\nNapisz program, który pobiera od użytkownika trzy dodatnie liczby całkowite \\(a, b, c\\). Na standardowym wyjściu wyświetl dodatnie liczby całkowite większe od \\(b\\), mniejsze lub równe od \\(a\\) i podzielne przez \\(c\\).\nNapisz program, który ze standardowego wejścia pobiera liczbę naturalną \\(a\\) a następnie wypisuje na standardowym wyjściu ile z cyfr liczby \\(a\\) jest równe 7.\nNapisać program, który wczyta z wejścia liczby całkowite aż do napotkania liczby ujemnej, a następnie wyświetla największy oraz najmniejszy element z wczytanych liczb (z pominięciem ostatniej, ujemnej liczby)."
  },
  {
    "objectID": "metody.html",
    "href": "metody.html",
    "title": "4  Funkcje/metody",
    "section": "",
    "text": "Napisz statyczną metodę, której jest dodatnia liczba całkowita \\(n\\). Metoda ma zwrócić jako liczbę całkowitą sumę szeregu\n\n\\[1-2+3-4+\\ldots \\pm n.\\] Stwórz przypadek testowy dla tej metody.\n\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\) (\\(n&gt;2\\)). Metoda ma zwrócić największą liczbę pierwszą mniejszą niż \\(n\\). Stwórz przypadek testowy dla tej metody.\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\). Metoda zwraca odpowiednią wartość logiczną sprawdzającą czy \\(n\\) jest liczbą doskonałą. Liczba doskonała to taka, której suma dzielników jest równa tej liczbie (liczbami doskonałymi są np. \\(1 = 1\\), \\(6 = 1 + 2 + 3\\)). Stwórz przypadek testowy dla metody.\nNapisz statyczną metodę, której parametrami są dwie dodatnie liczby całkowite \\(a\\) i \\(b\\). Metoda ma zwrócić najmniejszą wspólną wielokrotność (\\(NWW\\)) liczb \\(a\\) i \\(b\\). Stwórz przypadek testowy dla metody.\n\nPrzykład: \\(NWW(5,10)=10\\), \\(NWD(4,5)=20\\).\n\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\). Metoda zwraca true jeśli zadana liczba \\(n\\) jest nieparzysta, ujemna, (poza minusem) składa się z 4 cyfr i podzielna przez 5, oraz zwraca false w pozostałych przypadkach. Stwórz przypadek testowy dla metody.\nNapisz statyczną metodę, która jako argument otrzymuje dodatnią liczbę całkowitą \\(n\\) i zwraca liczbę \\(7^{-n}\\). Nie korzystaj z żadnych gotowych funkcji bibliotecznych ani wbudowanych wewnątrz tej funkcji poza instrukcjami wejścia/wyjścia. Stwórz przypadek testowy.\n\nPodpowiedź: \\(7^{-n}=\\frac{1}{7^n}\\).\n\nNapisz statyczną metodę, której argumentem są cztery dodatnie liczby całkowite \\(a, b, c, d\\). Metoda zwraca ile liczb całkowitych z przedziału \\((a,b)\\) jest podzielnych przez \\(c\\) i nie jest podzielnych przez \\(d\\). W przypadku braku takich liczb, zwróć zero. Stwórz przypadek testowy dla tej metody.\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\). Metoda zwraca sumę liczb całkowitych od \\(n\\) do \\(2n\\) (włącznie). Stwórz przypadek testowy dla metody.\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\). Metoda zwraca wartość wyrażenia: \\[\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\\]\n\nStwórz przypadek testowy dla metody.\n\nNapisz statyczną metodę, której argumentem jest dodatnia liczba całkowita \\(n\\). Metoda zwraca 1 jeśli \\(n\\) jest liczbą składającą się z samych jedynek w zapisie dziesiętnym oraz zwraca 0 w przeciwnym wypadku. Stwórz przypadek testowy dla metody."
  },
  {
    "objectID": "random.html",
    "href": "random.html",
    "title": "5  Generowanie liczb pseudolosowych",
    "section": "",
    "text": "Napisz metodę generateRandomInt, która generuje i zwraca losową liczbę całkowitą. Stwórz przypadek testowy.\nNapisz metodę generateRandomDouble, która generuje i zwraca losową liczbę zmiennoprzecinkową z zakresu od 0.0 do 1.0. Stwórz przypadek testowy.\nNapisz metodę generateRandomIntInRange, która przyjmuje dwie liczby całkowite jako argumenty i zwraca losową liczbę całkowitą z tego zakresu (włącznie z granicami). Na przykład, dla argumentów 5 i 10, metoda powinna zwracać liczbę z zakresu od 5 do 10. Stwórz przypadek testowy.\nNapisz metodę generateRandomGaussian, która generuje i zwraca losową liczbę zmiennoprzecinkową zgodnie z rozkładem normalnym. Stwórz przypadek testowy.\nNapisz metodę generateRandomBoolean, która generuje i zwraca losową wartość logiczną (true lub false). Stwórz przypadek testowy."
  },
  {
    "objectID": "tablice.html",
    "href": "tablice.html",
    "title": "6  Tablice",
    "section": "",
    "text": "Napisz program, który tworzy tablicę jednowymiarową 10 liczb całkowitych, a następnie wyświetla je w konsoli w porządku odwrotnym do wprowadzenia.\nUtwórz program, który tworzy jednowymiarową tablicę 20 liczb losowych z przedziału od 1 do 100, a następnie oblicza i wyświetla ich średnią wartość.\nNapisz program, który tworzy tablicę jednowymiarową 15 liczb całkowitych, a następnie oblicza i wyświetla największą i najmniejszą wartość w tablicy.\nUtwórz program, który tworzy jednowymiarową tablicę 30 liczb całkowitych. Następnie poproś użytkownika, aby podał dowolną liczbę. Program powinien wyświetlić informację, czy podana liczba znajduje się w tablicy, a także ile razy się w niej pojawia.\nNapisz program, który tworzy jednowymiarową tablicę 10 liczb całkowitych. Program powinien obliczać i wyświetlać sumę tych liczb, które są parzyste.\nNapisz program, który tworzy jednowymiarową tablicę 10 liczb zmiennoprzecinkowych, a następnie oblicza i wyświetla ich sumę.\nUtwórz program, który tworzy tablicę jednowymiarową 20 liczb zmiennoprzecinkowych, a następnie znajduje i wyświetla wartość średnią oraz medianę tych liczb.\nNapisz program, który tworzy jednowymiarową tablicę 10 liczb zmiennoprzecinkowych. Program powinien obliczać i wyświetlać sumę tych liczb, które są większe niż 0.5.\nNapisz program, który tworzy jednowymiarową tablicę 20 liczb całkowitych, a następnie oblicza i wyświetla ilość liczb parzystych i nieparzystych w tablicy.\nUtwórz program, który tworzy jednowymiarową tablicę 30 liczb całkowitych. Następnie program powinien obliczyć i wyświetlić ilość liczb, które są kwadratami innej liczby całkowitej.\nNapisz program, który tworzy jednowymiarową tablicę 50 liczb całkowitych. Program powinien obliczać i wyświetlać ilość liczb, które są liczbami pierwszymi.\nNapisz program, który tworzy jednowymiarową tablicę 15 liczb całkowitych, a następnie oblicza i wyświetla sumę liczb, które są podzielne przez 3.\nNapisz statyczną metodę minimumValue, która przyjmuje tablicę liczb całkowitych jako argument i zwraca najmniejszą liczbę w tablicy. Przyjmij, że tablica zawsze będzie miała co najmniej jeden element. Jeżeli tablica zawiera tylko jeden element, zwróć ten element. Stwórz przypadek testowy.\nNapisz statyczną metodę average, która przyjmuje tablicę liczb zmiennoprzecinkowych jako argument i zwraca średnią arytmetyczną wszystkich liczb w tablicy. Jeżeli tablica jest pusta, zwróć 0. Stwórz przypadek testowy.\nNapisz statyczną metodę reverseArray, która przyjmuje tablicę liczb całkowitych jako argument i zwraca tę samą tablicę, ale z odwróconym porządkiem elementów. Na przykład, dla tablicy [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę reverseArray, która przyjmuje tablicę liczb całkowitych jako argument. Metoda odwraca porządek elementów w tablicy i powinna być procedurą. Na przykład, dla tablicy [1, 2, 3, 4, 5], funkcja powinna zmienić tablicę na [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę countZeros, która przyjmuje tablicę liczb całkowitych jako argument i zwraca liczbę wystąpień zera w tablicy. Na przykład, dla tablicy [0, 1, 2, 0, 3, 0, 4], funkcja powinna zwrócić 3. Stwórz przypadek testowy.\nNapisz statyczną metodę oddElementsSum, która przyjmuje tablicę liczb całkowitych jako argument i zwraca sumę wszystkich nieparzystych liczb w tablicy. Jeżeli w tablicy nie ma żadnych nieparzystych liczb, funkcja powinna zwrócić 0. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArray, która przyjmuje tablicę liczb całkowitych jako argument i zwraca nową tablicę, która jest kopią pierwotnej. Funkcja powinna skopiować tablicę ręcznie, element po elemencie, bez korzystania z systemowych metod kopiowania. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayReverse, która przyjmuje tablicę liczb całkowitych jako argument i zwraca nową tablicę, która jest odwróconą kopią pierwotnej. Na przykład, dla tablicy [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayEven, która przyjmuje tablicę liczb całkowitych jako argument i zwraca nową tablicę zawierającą tylko parzyste liczby z pierwotnej tablicy. Na przykład, dla tablicy [1, 2, 3, 4, 5], funkcja powinna zwrócić [2, 4]. Jeżeli w tablicy nie ma żadnych parzystych liczb, funkcja powinna zwrócić pustą tablicę. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayWithIndex, która przyjmuje tablicę liczb całkowitych oraz indeks początkowy i końcowy jako argumenty. Funkcja powinna zwrócić nową tablicę zawierającą elementy pierwotnej tablicy od indeksu początkowego do końcowego (włącznie). Na przykład, dla tablicy [1, 2, 3, 4, 5] i indeksów 1 i 3, funkcja powinna zwrócić [2, 3, 4]. Stwórz przypadek testowy.\nNapisz statyczną metodę mergeArrays, która przyjmuje dwie tablice liczb całkowitych jako argumenty. Funkcja powinna zwrócić nową tablicę, która jest połączeniem obu pierwotnych tablic. Na przykład, dla tablic [1, 2, 3] i [4, 5, 6], funkcja powinna zwrócić [1, 2, 3, 4, 5, 6]. Stwórz przypadek testowy.\nNapisz metodę sortArray, która przyjmuje tablicę liczb całkowitych jako argument i zwraca nową tablicę, która jest posortowaną wersją pierwotnej tablicy. Wykorzystaj metodę Arrays.sort() z biblioteki java.util.Arrays do posortowania tablicy. Stwórz przypadek testowy.\nNapisz metodę checkEquality, która przyjmuje dwie tablice liczb całkowitych jako argumenty i zwraca wartość true, jeśli tablice są równe, a false w przeciwnym razie. Wykorzystaj metodę Arrays.equals() z biblioteki java.util.Arrays do porównania tablic. Stwórz przypadek testowy.\nNapisz metodę fillArray, która przyjmuje tablicę liczb całkowitych i liczbę całkowitą jako argumenty. Metoda powinna wypełnić tablicę podaną liczbą, wykorzystując do tego metodę Arrays.fill() z biblioteki java.util.Arrays. Stwórz przypadek testowy.\nNapisz metodę printArray, która przyjmuje tablicę liczb całkowitych jako argument i drukuje jej zawartość na konsoli. Wykorzystaj do tego metodę Arrays.toString() z biblioteki java.util.Arrays, która zwraca tekstową reprezentację tablicy. Stwórz przypadek testowy.\nNapisz metodę copyArray, która przyjmuje tablicę liczb wymiernych jako argument. Metoda powinna zwracać nową tablicę, będącą kopią przekazanej tablicy. Do skopiowania tablicy wykorzystaj metodę Arrays.copyOf() z biblioteki java.util.Arrays. Stwórz przypadek testowy.\nNapisz metodę sortArray, która przyjmuje tablicę liczb wymiernych jako argument. Metoda powinna sortować tablicę w porządku rosnącym, wykorzystując do tego metodę Arrays.sort() z biblioteki java.util.Arrays. Stwórz przypadek testowy."
  },
  {
    "objectID": "arraylist.html",
    "href": "arraylist.html",
    "title": "7  ArrayList (listy tablicowe)",
    "section": "",
    "text": "Napisz program, który tworzy listę tablicową 10 liczb całkowitych, a następnie wyświetla je w konsoli w porządku odwrotnym do wprowadzenia.\nNapisz program, który tworzy listę tablicową 10 liczb zmiennoprzecinkowych, a następnie oblicza i wyświetla ich sumę.\nNapisz statyczną metodę minimumValue, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca najmniejszą liczbę w liście tablicowej. Przyjmij, że lista tablicowa zawsze będzie miała co najmniej jeden element. Stwórz przypadek testowy.\nNapisz statyczną metodę minimumValue, która przyjmuje listę tablicową liczb wymiernych jako argument i zwraca najmniejszą liczbę w liście tablicowej. Przyjmij, że lista tablicowa zawsze będzie miała co najmniej jeden element. Stwórz przypadek testowy.\nNapisz statyczną metodę average, która przyjmuje listę tablicową liczb zmiennoprzecinkowych jako argument i zwraca średnią arytmetyczną wszystkich liczb. Jeżeli lista tablicowa jest pusta, zwróć 0. Stwórz przypadek testowy.\nNapisz statyczną metodę reverseArray, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca tę samą listę tablicową, ale z odwróconym porządkiem elementów. Na przykład, dla [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę reverseArray, która przyjmuje listę tablicową liczb całkowitych jako argument. Metoda odwraca porządek elementów w liście tablicowej i powinna być procedurą. Na przykład, dla [1, 2, 3, 4, 5], funkcja powinna zmienić listę tablicową na [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę countZeros, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca liczbę wystąpień zera w liście tablicowej. Na przykład, dla [0, 1, 2, 0, 3, 0, 4], funkcja powinna zwrócić 3. Stwórz przypadek testowy.\nNapisz statyczną metodę oddElementsSum, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca sumę wszystkich nieparzystych liczb w liście tablicowej. Jeżeli w liście tablicowej nie ma żadnych nieparzystych liczb, funkcja powinna zwrócić 0. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArray, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca nową listę tablicową, która jest kopią pierwotnej. Funkcja powinna skopiować listę tablicową ręcznie, element po elemencie, bez korzystania z systemowych metod kopiowania. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayReverse, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca nową listę tablicową, która jest odwróconą kopią pierwotnej. Na przykład, dla liście tablicowej [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayEven, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca nową listę tablicową zawierającą tylko parzyste liczby z pierwotnej liście tablicowej. Na przykład, dla liście tablicowej [1, 2, 3, 4, 5], funkcja powinna zwrócić [2, 4]. Jeżeli w liście tablicowej nie ma żadnych parzystych liczb, funkcja powinna zwrócić pustą listę tablicową. Stwórz przypadek testowy.\nNapisz statyczną metodę copyArrayWithIndex, która przyjmuje listę tablicową liczb całkowitych oraz indeks początkowy i końcowy jako argumenty. Funkcja powinna zwrócić nową listę tablicową zawierającą elementy pierwotnej liście tablicowej od indeksu początkowego do końcowego (włącznie). Na przykład, dla liście tablicowej [1, 2, 3, 4, 5] i indeksów 1 i 3, funkcja powinna zwrócić [2, 3, 4]. Stwórz przypadek testowy.\nNapisz statyczną metodę mergeArrays, która przyjmuje dwie tablice liczb całkowitych jako argumenty. Funkcja powinna zwrócić nową listę tablicową, która jest połączeniem obu pierwotnych tablic. Na przykład, dla list tablicowych [1, 2, 3] i [4, 5, 6], funkcja powinna zwrócić [1, 2, 3, 4, 5, 6]. Stwórz przypadek testowy.\nNapisz metodę sortArray, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca nową listę tablicową, która jest posortowaną wersją pierwotnej liście tablicowej. Stwórz przypadek testowy."
  },
  {
    "objectID": "napisy.html",
    "href": "napisy.html",
    "title": "8  Napisy",
    "section": "",
    "text": "Napisz statyczną metodę, która przyjmuje napis jako argument i zwraca ten napis w odwrotnej kolejności. Stwórz przypadek testowy.\nNapisz statyczną metodę, która sprawdza, czy dany napis jest palindromem. Palindrom to słowo, fraza, liczba lub inny ciąg znaków, który czyta się tak samo od przodu, jak i od tyłu. Stwórz przypadek testowy.\nNapisz statyczną metodę, która usuwa wszystkie spacje z danego napisu. Stwórz przypadek testowy.\nNapisz statyczną metodę, która przyjmuje napis jako argument i zwraca ten napis z zamienioną pierwszą i ostatnią literą. Stwórz przypadek testowy.\nNapisz program, który analizuje dany napis pod kątem częstotliwości występowania każdego ze znaków. Program powinien wyświetlić znak i liczbę jego wystąpień w danym napisie. Dane pobierz ze standardowego wejścia.\nNapisz program, który przyjmuje napis jako wejście i wypisuje wszystkie znaki znajdujące się na parzystych indeksach napisu, używając metody charAt.\nUżywając metody charAt, napisz statyczną metodę, która sprawdza, czy dany napis zaczyna się i kończy tym samym znakiem. Stwórz przypadek testowy.\nNapisz program, który przyjmuje trzy napisy: główny napis, prefiks i sufiks. Używając metod startsWith oraz endsWith, sprawdź czy główny napis zaczyna się od podanego prefiksu i kończy podanym sufiksem. Wypisz odpowiedni komunikat dla każdego z tych przypadków.\nNapisz program, który przyjmuje jako wejście pojedynczy znak oraz liczbę całkowitą n. Używając klasy StringBuilder, zbuduj i wypisz piramidę o wysokości n, gdzie każdy poziom piramidy składa się z podanego znaku. Na przykład dla znaku * i n=3, oczekiwany wynik to:\n\n *\n***\n*****\n\nDany jest napis. Używając StringBuilder, napisz program, który usuwa wszystkie powtarzające się znaki, pozostawiając tylko pierwsze wystąpienie każdego znaku. Na przykład dla napisu “bananowy”, oczekiwany wynik to “banowy”.\nNapisz program, który przyjmuje zdanie jako wejście. Używając StringBuilder, odwróć każde słowo w zdaniu, ale zachowaj kolejność słów. Na przykład dla zdania “Java jest fajna”, oczekiwany wynik to “avaJ tsej anjaf”.\nNapisz metodę statyczną reverseString, która przyjmuje jako argument obiekt typu StringBuilder i zwraca nowy StringBuilder, będący odwróconym napisem pierwotnym. Stwórz przypadek testowy.\nNapisz metodę statyczną removeDuplicates, która przyjmuje StringBuilder i usuwa wszystkie powtarzające się znaki w napisie, pozostawiając tylko pierwsze wystąpienie danego znaku. Stwórz przypadek testowy.\nNapisz metodę statyczną mostFrequentChar, która przyjmuje StringBuilder jako argument i zwraca znak, który występuje najczęściej w napisie. W przypadku remisów, zwróć pierwszy znak z remisowych. Stwórz przypadek testowy.\nNapisz metodę statyczną insertSubstring, która przyjmuje dwa argumenty: StringBuilder sb oraz String toInsert. Metoda ma wstawiać toInsert w środek pierwotnego StringBuilder. Stwórz przypadek testowy.\nNapisz metodę statyczną splitByEvenOdd, która przyjmuje StringBuilder jako argument. Metoda powinna zwracać tablicę dwóch elementów typu StringBuilder. Pierwszy element tablicy ma zawierać znaki z nieparzystych indeksów pierwotnego napisu, a drugi z parzystych. Stwórz przypadek testowy.\nNapisz metodę statyczną capitalizeEverySecond, która przyjmuje jako argument obiekt typu StringBuffer. Metoda ma zmienić każdą drugą literę na wielką. Stwórz przypadek testowy.\nNapisz metodę statyczną replaceSubstring, która przyjmuje dwa argumenty: StringBuffer sb i String oldSub, oraz String newSub. Metoda ma zamienić wszystkie wystąpienia podciągu oldSub na newSub. Stwórz przypadek testowy.\nNapisz metodę statyczną countOccurrences, która przyjmuje dwa argumenty: StringBuffer sb oraz char c. Metoda powinna zwracać liczbę wystąpień znaku c w napisie. Stwórz przypadek testowy.\nNapisz metodę statyczną trimToSize, która przyjmuje StringBuffer sb i liczbę całkowitą n. Metoda ma zmniejszyć długość napisu do n znaków (jeśli pierwotny napis jest dłuższy). Jeśli napis jest krótszy lub równy n, nie powinien ulec zmianie. Stwórz przypadek testowy.\nNapisz metodę statyczną isPalindrome, która przyjmuje StringBuffer jako argument. Metoda powinna sprawdzić, czy napis jest palindromem (odczytywany tak samo od przodu jak i od tyłu) i zwrócić odpowiednią wartość logiczną. Stwórz przypadek testowy."
  },
  {
    "objectID": "klasaobiekt.html",
    "href": "klasaobiekt.html",
    "title": "9  Pojęcie klasy/obiektu",
    "section": "",
    "text": "Utwórz klasę Dog z polami: name, breed i age. Napisz metodę bark(), która wydrukuje na konsoli \"Hau Hau\". Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nStwórz klasę Car z polami: brand, model i speed. Napisz metody accelerate(int value) i decelerate(int value), które odpowiednio zwiększają i zmniejszają prędkość o podaną wartość. Stwórz przypadek testowy, aby wywołać każdą metodę co najmniej jeden raz.\nStwórz klasę BankAccount z polem balance. Napisz metody deposit(double amount) i withdraw(double amount), które odpowiednio zwiększają i zmniejszają saldo o daną kwotę. Stwórz przypadek testowy, aby wywołać każdą metodę co najmniej jeden raz.\nUtwórz klasę Point z dwoma polami: x i y reprezentującymi współrzędne na płaszczyźnie. Napisz metodę distance(Point otherPoint), która oblicza odległość między bieżącym punktem a innym punktem. Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nStwórz klasę Time z polami: hours i minutes. Napisz metodę addTime(Time otherTime), która dodaje do bieżącego czasu czas podany jako argument i zwraca nowy obiekt klasy Time. Zadbaj o to, aby minuty i godziny nie przekraczały odpowiednio 59 i 23. Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nWykonaj po kolei dwa podpunkty:\nA. Stwórz klasę Car zawierającą pole brand. W klasie Main, utwórz obiekt klasy Car, przypisz mu wartość null i spróbuj odwołać się do pola brand. Jaki jest wynik?\nB. Zmodyfikuj kod z podpunktu A tak, aby sprawdzić, czy obiekt Car jest null przed odwołaniem się do pola brand. Jaki jest wynik?\nUtwórz klasę Osoba zawierającą pole imie. W klasie Main, utwórz dwa obiekty klasy Osoba - osoba1 i osoba2 - oba odnoszące się do tego samego obiektu. Zmień wartość pola imie przez osoba1 i wydrukuj wartość pola imie przez osoba2. Przeanalizuj wynik.\nStwórz tablicę obiektów klasy Samochod. Następnie spróbuj odwołać się do pola marka jednego z obiektów w tablicy, nie inicjalizując wcześniej tablicy obiektami Samochod. Przeanalizuj wynik.\nStwórz listę tablicową (Arraylistę) obiektów klasy Osoba. Następnie spróbuj odwołać się do pola imie jednego z obiektów na liście, nie dodając wcześniej do listy żadnych obiektów Osoba. Przeanalizuj wynik.\nUtwórz klasę Pies z metodą szczekaj, która wydrukuje wiadomość “Hau! Hau!”. W klasie Main utwórz obiekt Pies, przypisz mu wartość null i spróbuj wywołać metodę szczekaj. Przeanalizuj wynik.\nStwórz klasę Kot z polem imie. Dodaj do klasy Kot metodę stworzKota, która zwraca nowy obiekt klasy Kot. Metoda powinna ustawiać pole imie na podaną wartość, ale tylko jeśli wartość nie jest null. W przeciwnym razie powinna zwracać null. W klasie Main użyj metody stworzKota do stworzenia obiektu kot, a następnie spróbuj wydrukować wartość pola imie. Co się stanie, jeśli przekażesz null jako argument do metody stworzKota? Przeanalizuj wynik.\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę Czlowiek z polem imie. Dodaj do klasy metodę przedstawSie, która wyświetli wiadomość “Cześć, jestem” i imię osoby. W klasie Main, utwórz obiekt Czlowiek i wywołaj na nim metodę przedstawSie. Czy musisz użyć słowo kluczowe this w implementacji metody?\nDodaj do klasy Czlowiek metodę powiedzCzesc, która jako argument przyjmuje inny obiekt klasy Czlowiek i wyświetla wiadomość “Cześć,” i imię drugiego człowieka. Przeanalizuj działanie.\nDodaj do klasy Czlowiek metodę zmienImie, która jako argument przyjmuje łańcuch znaków i przypisuje go do pola imie. Utwórz obiekt Czlowiek i użyj metody zmienImie do zmiany jego imienia. Następnie wywołaj metodę przedstawSie. Czy imię zostało zmienione? Czy musisz użyć słowo kluczowe this w implementacji metody?\nDodaj do klasy Czlowiek metodę zamienImionami, która jako argument przyjmuje inny obiekt klasy Czlowiek i zamienia imionami obie osoby. Utwórz dwa obiekty Czlowiek i użyj metody zamienImionami do zamiany ich imion. Następnie wywołaj metodę przedstawSie na obu obiektach. Czy imiona zostały zamienione?\n\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę Licznik z jednym polem liczba. Dodaj do klasy metodę zwieksz, która przyjmuje parametr typu int i zwiększa wartość pola liczba o wartość tego parametru. W klasie Main, utwórz zmienną typu int, przekaż ją do metody zwieksz i sprawdź, czy wartość zmiennej zmieniła się po wywołaniu metody.\nDodaj do klasy Licznik metodę dodaj, która przyjmuje inny obiekt Licznik i dodaje wartość jego pola liczba do pola liczba bieżącego obiektu. Utwórz dwa obiekty Licznik w klasie Main i użyj metody dodaj. Sprawdź, czy obiekt przekazany jako argument metody dodaj zmienił swoją wartość po wywołaniu metody.\nStwórz klasę Zmieniacz, która posiada metodę zmienWartosc, która jako argument przyjmuje typ int. Wewnątrz metody zmień wartość argumentu na inną. W klasie Main utwórz zmienną int, a następnie przekaż ją do metody zmienWartosc i sprawdź, czy wartość zmiennej się zmieniła.\nDodaj do klasy Zmieniacz metodę zmienObiekt, która jako argument przyjmuje obiekt Licznik. Wewnątrz metody zmień wartość pola liczba obiektu Licznik na inną. W klasie Main utwórz obiekt Licznik, a następnie przekaż go do metody zmienObiekt i sprawdź, czy wartość pola liczba obiektu się zmieniła.\n\nZdefiniuj klasę Punkt, która reprezentuje punkt w przestrzeni 3D (o współrzędnych x, y i z). Klasa powinna mieć metody do zmiany wartości współrzędnych. W Main stwórz dwa obiekty tej klasy i przetestuj różnicę pomiędzy przekazywaniem parametrów przez wartość i przez referencję."
  },
  {
    "objectID": "modyfikatorydostepu.html",
    "href": "modyfikatorydostepu.html",
    "title": "10  Modyfikatory dostępu",
    "section": "",
    "text": "Utwórz klasę Osoba z publicznym polem imie oraz prywatnym polem haslo. Zobacz jak różne modyfikatory dostępu wpływają na dostęp do tych pól z innej klasy.\nStwórz dwie klasy: Rodzic i Dziecko. Klasa Rodzic powinna mieć jedno pole protected. Spróbuj uzyskać dostęp do tego pola z klasy Dziecko.\nUtwórz klasę Samochod z prywatną metodą zawalSilnik(). Spróbuj wywołać tę metodę z zewnątrz klasy.\nStwórz dwie klasy w tym samym pakiecie: Pracownik i Firma. Klasa Pracownik powinna mieć pole bez modyfikatora dostępu. Spróbuj uzyskać dostęp do tego pola z klasy Firma.\nUtwórz klasę KontoBankowe z publicznym polem numerKonta i prywatnym polem saldo. Zobacz, jak różne modyfikatory dostępu wpływają na dostęp do tych pól z innej klasy.\nStwórz klasę Zawodnik z trzema polami: imie (publiczne), wiek (pomijając modyfikator dostępu) oraz narodowosc (prywatne). W klasie Main stwórz tablicę zawodników i spróbuj zmienić wartości wszystkich pól. Obserwuj rezultaty.\nStwórz klasę Trener, która jest zadeklarowana jako private. Spróbuj stworzyć obiekt Trener w klasie Main. Jaki jest rezultat?"
  },
  {
    "objectID": "konstruktor.html",
    "href": "konstruktor.html",
    "title": "11  Konstruktor",
    "section": "",
    "text": "Napisz klasę Ksiazka, która będzie zawierać trzy pola: tytul, autor, rokWydania. Następnie zaimplementuj dwa konstruktory - jeden domyślny, który nie przyjmuje żadnych argumentów, i drugi, który przyjmuje trzy argumenty odpowiadające polom klasy. W przypadku drugiego konstruktora, nazwy parametrów muszą być takie same jak nazwy pól. Sprawdź czy jesteś w stanie prawidłowo przypisać wartości do pól klasy używając słowa kluczowego this.\nZaprojektuj klasę Osoba, która będzie zawierać dwa pola: imie, nazwisko. Zaimplementuj konstruktor, który przyjmuje dwa argumenty odpowiadające polom klasy. Nazwy parametrów muszą być takie same jak nazwy pól. Spróbuj przypisać wartości do pól klasy bez używania słowa kluczowego this. Czy jest to możliwe? Jeżeli nie, to dlaczego?\nStwórz klasę Samochod, która będzie zawierać trzy pola: marka, model, rokProdukcji. Zaimplementuj trzy konstruktory - pierwszy domyślny, drugi przyjmujący dwa argumenty (marka i model), trzeci przyjmujący trzy argumenty (marka, model, rokProdukcji). W przypadku drugiego i trzeciego konstruktora, nazwy parametrów muszą być takie same jak nazwy pól. Wykorzystaj słowo kluczowe this do rozróżnienia pól klasy od parametrów.\nNapisz klasę Osoba, która będzie miała pola: imie, nazwisko i wiek. Zdefiniuj w niej dwa konstruktory, jeden przyjmujący wszystkie trzy parametry, a drugi tylko imię i nazwisko. Drugi konstruktor powinien wywołać pierwszy, przekazując mu domyślną wartość wieku jako 0.\nZaprojektuj klasę Kwadrat, która posiada pole bok oraz konstruktor, który umożliwia ustawienie wartości tego pola. Następnie napisz drugi konstruktor, który nie przyjmuje żadnych argumentów, a jedynie wywołuje pierwszy konstruktor z wartością domyślną 1.\nZdefiniuj klasę Samochod, która ma pola: marka, model i rokProdukcji. Klasa powinna zawierać dwa konstruktory: pierwszy przyjmujący wszystkie trzy parametry, a drugi tylko markę i model. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość rokProdukcji jako aktualny rok.\nStwórz klasę Pies, która posiada pola: imie, rasa i wiek. Klasa powinna mieć dwa konstruktory: jeden, który przyjmuje wszystkie trzy parametry, a drugi, który przyjmuje tylko imię i rasę. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość wieku jako 1.\nNapisz klasę Student, która ma pola: imie, nazwisko i kierunekStudiow. Zdefiniuj w niej dwa konstruktory, jeden przyjmujący wszystkie trzy parametry, a drugi tylko imię i nazwisko. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość kierunku studiów jako nieznany.\nZdefiniuj klasę Pracownik, która posiada pola: imie, nazwisko i pensja. Napisz konstruktor, który przyjmuje dwa argumenty (imię i nazwisko), oraz blok inicjujący, który ustawia wartość pensji na 3000. Sprawdź, co stanie się, gdy w konstruktorze spróbujesz nadpisać wartość pensji.\nZaprojektuj klasę Samochod, która posiada pola: marka, model i cena. Napisz konstruktor, który przyjmuje dwa argumenty (marka i model), a w bloku inicjującym ustaw domyślną wartość ceny na 50000. Zobacz, co stanie się, gdy w konstruktorze spróbujesz zmienić wartość ceny.\nZdefiniuj klasę Telefon, która ma pola: producent, model i system. W bloku inicjującym ustaw wartość system na Android. Następnie napisz konstruktor, który przyjmuje dwa argumenty (producent i model) i próbuje nadpisać wartość system na iOS. Sprawdź, która wartość zostanie ostatecznie przypisana do pola system.\nStwórz klasę Samochod zawierającą prywatne pola: marka, model, rokProdukcji, przebieg oraz kolor. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) dla wszystkich pól. Następnie dodaj metodę wyswietlInformacje(), która wyświetla wszystkie informacje o samochodzie.\nStwórz klasę Osoba z prywatnymi polami: imie, nazwisko, wiek, adres. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę przedstawSie(), która zwraca łańcuch znaków z informacjami o osobie.\nStwórz klasę Ksiazka z prywatnymi polami: tytul, autor, rokWydania, wydawnictwo oraz liczbaStron. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę pokazInformacje(), która wyświetla informacje o książce.\nStwórz klasę Punkt2D z prywatnymi polami x i y, reprezentującymi współrzędne punktu na płaszczyźnie. Dodaj konstruktor, który przyjmuje współrzędne jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę odleglosc(Punkt2D innyPunkt), która oblicza odległość między dwoma punktami na płaszczyźnie.\nStwórz klasę Prostokat z prywatnymi polami szerokosc i wysokosc. Dodaj konstruktor, który przyjmuje długości boków jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody pole() i obwod(), które obliczają pole powierzchni i obwód prostokąta.\nStwórz klasę Kolo z prywatnym polem promien. Dodaj konstruktor, który przyjmuje promień jako argument. Dodaj metody dostępowe (gettery i settery) oraz metody pole() i obwod(), które obliczają pole powierzchni i obwód koła.\nStwórz klasę Student z prywatnymi polami: imie, nazwisko, numerIndeksu, rokStudiow oraz sredniaOcen. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę pokazInformacje(), która wyświetla informacje o studencie.\nStwórz klasę Pracownik z prywatnymi polami: imie, nazwisko, stanowisko, wiek oraz placa. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę pokazInformacje(), która wyświetla informacje o pracowniku.\nStwórz klasę KontoBankowe z prywatnymi polami: numerKonta, wlasciciel, saldo oraz typKonta. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody wplac(double kwota) i wyplac(double kwota), które odpowiednio dodają lub odejmują kwotę od salda konta.\nStwórz klasę Telewizor z prywatnymi polami: marka, przekatnaEkranu, rozdzielczosc, czySmartTV oraz cena. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę pokazInformacje(), która wyświetla informacje o telewizorze.\nStwórz klasę DziennikOcen z prywatnymi polami: imie, nazwisko oraz oceny (jako ArrayList typu int). Dodaj konstruktor, który przyjmuje imię i nazwisko jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody dodajOcene(int ocena) i usunOcene(int indeks), które odpowiednio dodają lub usuwają ocenę z listy ocen. Dodaj również metodę sredniaOcen() do obliczania średniej ocen.\nStwórz klasę HistoriaTemperatur z prywatnym polem temperatury (jako ArrayList typu double). Dodaj konstruktor domyślny. Dodaj metody dostępowe (gettery i settery) oraz metody dodajTemperature(double temperatura) i usunTemperature(int indeks), które odpowiednio dodają lub usuwają temperaturę z listy temperatur. Dodaj również metodę sredniaTemperatur() do obliczania średniej temperatur.\nStwórz klasę WynikiTestow z prywatnymi polami: imie, nazwisko oraz wyniki (jako tablica typu int). Dodaj konstruktor, który przyjmuje imię, nazwisko oraz rozmiar tablicy jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę dodajWynik(int indeks, int wynik), która dodaje wynik testu na podanym indeksie. Dodaj również metodę sredniWynik() do obliczania średniego wyniku.\nStwórz klasę ZarzadcaZadan z prywatnym polem priorytetyZadan (jako ArrayList typu int). Dodaj konstruktor domyślny. Dodaj metody dostępowe (gettery i settery) oraz metody dodajPriorytet(int priorytet) i usunPriorytet(int indeks), które odpowiednio dodają lub usuwają priorytet z listy priorytetów. Dodaj również metodę najwyzszyPriorytet() do znajdowania najwyższego priorytetu.\nStwórz klasę Magazyn z prywatnym polem iloscProduktow (jako tablica typu int). Dodaj konstruktor, który przyjmuje rozmiar tablicy jako argument. Dodaj metody dostępowe (gettery i settery) oraz metodę dodajProdukty(int indeks, int ilosc), która dodaje określoną ilość produktów na podanym indeksie. Dodaj również metodę sumaProduktow() do obliczania sumy wszystkich produktów w magazynie.\nZdefiniuj klasę Osoba, która posiada pola: imię, nazwisko i wiek. Napisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól. Wiek osoby nie powinien być ujemny, a imię i nazwisko nie powinny być puste.\nStwórz klasę Punkt, reprezentującą punkt w przestrzeni 3D, z polami: x, y, z. Napisz konstruktor, który przyjmuje te trzy wartości i sprawdza, czy są one w zakresie od -100 do 100. Jeśli wartości nie są w tym zakresie, powinny być ustawione na najbliższą granicę.\nZaprojektuj klasę Samochod, która posiada pola: marka, model i rokProdukcji. Napisz konstruktor, który przyjmuje trzy argumenty. Zadaniem konstruktora jest sprawdzenie, czy rokProdukcji nie jest większy niż aktualny rok oraz czy marka i model nie są puste.\nZdefiniuj klasę KontoBankowe, która posiada pola: numerKonta i saldo. Napisz konstruktor, który przyjmuje dwa argumenty. Przed przypisaniem wartości do pola numerKonta, sprawdź, czy jest ono 26-cyfrowe, a przed przypisaniem wartości do pola saldo, sprawdź, czy saldo nie jest ujemne."
  },
  {
    "objectID": "zlozonepolawklasie.html",
    "href": "zlozonepolawklasie.html",
    "title": "12  Złożone pola w klasie",
    "section": "",
    "text": "Utwórz klasę AlbumMuzyczny z polami tytul, artysta oraz oceny (jako tablica z elementami typu double). Dodaj metodę pozwalającą na dodawanie i usuwanie ocen. Utwórz klasę AlbumRockowy, która dziedziczy po klasie AlbumMuzyczny.Klasa AlbumRockowy powinna mieć dodatkowe pole gatunekRocka. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Ksiazka z polami tytul, autor oraz recenzje (jako tablica z elementami typu double). Dodaj metody pozwalające na dodawanie i usuwanie recenzji. Utwórz klasę KsiazkaFantasy, która dziedziczy po klasie Ksiazka. Klasa KsiazkaFantasy powinna mieć dodatkowe pole podgatunekFantasy. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę GraKomputerowa z polami tytul, producent oraz oceny (jako tablica z elementami typu double). Dodaj metody pozwalające na dodawanie i usuwanie ocen. Utwórz klasę GraRPG, która dziedziczy po klasie GraKomputerowa. Klasa GraRPG powinna mieć dodatkowe pole światGry. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Uniwersytet z polami nazwa, lokalizacja oraz kierunkiStudiow (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie kierunków studiów. Utwórz klasę UniwersytetTechniczny, która dziedziczy po klasie Uniwersytet. Klasa UniwersytetTechniczny powinna mieć dodatkowe pole liczbaLaboratoriow. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę GaleriaSztuki z polami nazwa, miasto oraz obrazy (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie obrazów. Utwórz klasę GaleriaWspolczesna, która dziedziczy po klasie GaleriaSztuki. Klasa GaleriaWspolczesna powinna mieć dodatkowe pole liczbaInstalacji. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Samochod z polami marka, model oraz wariantySilnikow (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie wariantów silników. Utwórz klasę SamochodElektryczny, która dziedziczy po klasie Samochod. Klasa SamochodElektryczny powinna mieć dodatkowe pole zasieg. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody."
  },
  {
    "objectID": "static.html",
    "href": "static.html",
    "title": "13  Pola i metody statyczne",
    "section": "",
    "text": "Stwórz klasę Osoba. Klasa powinna zawierać pole imienne oraz statyczne pole licznik. Zadaniem jest zwiększanie wartości licznik za każdym razem, gdy tworzona jest nowa instancja klasy Osoba. Dodaj metodę, która zwróci wartość licznik. Stwórz przypadek testowy.\nStwórz klasę Matematyka, która posiada pole statyczne PI, które przechowuje przybliżoną wartość liczby \\(\\pi\\). Upewnij się, że wartość tego pola jest niemutowalna. Stwórz przypadek testowy.\nStwórz klasę Singleton, która używa pola statycznego do przechowywania jednej i tylko jednej instancji tej klasy. Klasa powinna zawierać prywatny konstruktor oraz publiczną statyczną metodę getInstance(), która zwraca jedyną instancję klasy Singleton. Stwórz przypadek testowy.\nStwórz klasę Konfiguracja, która zawiera pole statyczne wersjaAplikacji z domyślną wartością “1.0”. Dodaj metody pozwalające na odczyt i zmianę tej wartości. Stwórz przypadek testowy.\nStwórz klasę Kalkulator, która posiada podstawowe metody matematyczne: dodawanie, odejmowanie, mnożenie i dzielenie. Zaimplementuj te metody jako metody statyczne. Utwórz drugą klasę, w której przetestujesz te metody bez tworzenia instancji klasy Kalkulator.\nStwórz klasę FabrykaFigur, która posiada metody statyczne do tworzenia różnych figur geometrycznych, takich jak koła, kwadraty czy trójkąty. Następnie stwórz klasę testową, w której wykorzystasz te metody do stworzenia różnych figur, bez potrzeby tworzenia instancji klasy FabrykaFigur.\nStwórz klasę Ustawienia, która posiada różne parametry konfiguracyjne aplikacji (np. wersja, język). Dodaj metody niestatyczne do zmiany tych parametrów oraz statyczną metodę domyslneUstawienia(), która zwróci domyślną konfigurację aplikacji. W klasie testowej zobacz, jak działają obie grupy metod i jakie są między nimi różnice.\nUtwórz klasę Konfiguracja, która posiada pole statyczne wersjaAplikacji oraz pole statyczne nazwaAplikacji. Jedno z tych pól oznacz jako final. Zastanów się, co by się stało, gdybyś chciał zaktualizować wartość jednego z tych pól w trakcie działania aplikacji.\nStwórz klasę Produkt, która zawiera pole statyczne liczbaProduktow oraz pole statyczne MAX_PRODUKTOW. Pole liczbaProduktow będzie służyć do zliczania ilości utworzonych produktów, a MAX_PRODUKTOW do ograniczenia ich liczby. Oznacz tylko jedno z tych pól słowem kluczowym final i zastanów się nad konsekwencjami tego wyboru."
  },
  {
    "objectID": "rekord.html",
    "href": "rekord.html",
    "title": "14  Rekordy",
    "section": "",
    "text": "Stwórz rekord KsiążkaDTO, który reprezentuje książkę w sklepie internetowym. Powinien zawierać takie informacje jak tytuł, autor, cena i rok wydania. Następnie stwórz kilka instancji tego rekordu, reprezentujących różne książki.\nUtwórz rekord Adres, który zawiera ulicę, numer domu, kod pocztowy i miasto. Następnie, stwórz rekord Osoba, który oprócz podstawowych informacji o osobie (np. imię, nazwisko) zawiera również pole typu Adres. Stwórz przypadek testowy.\nStwórz klasę PunktKlasy reprezentującą punkt na płaszczyźnie 2D z polami x i y. Następnie, stwórz rekord PunktRekord z tymi samymi polami. Dodaj metody umożliwiające konwersję z instancji klasy na rekord i odwrotnie. Stwórz przypadek testowy.\nStwórz rekord Książka, który reprezentuje tytuł, autora i rok wydania. Dodaj metodę opis(), która zwraca sformatowaną postać informacji o książce w stylu “Autor - Tytuł (Rok wydania)”. Stwórz przypadek testowy.\nStwórz rekord Punkt2D, reprezentujący punkt na płaszczyźnie 2D z koordynatami x i y. Wprowadź metodę odlegloscDo(Punkt2D innyPunkt), która oblicza i zwraca odległość euklidesową między aktualnym punktem a podanym jako argument. Stwórz przypadek testowy.\nStwórz rekord Samochód, który zawiera markę, model i spalanie na 100km. Dodaj metodę kosztPaliwa(double cenaPaliwa, double dystans), która oblicza i zwraca koszt podróży na podstawie podanej ceny paliwa oraz dystansu. Stwórz przypadek testowy.\nStwórz rekord Uczeń, który reprezentuje imię, nazwisko i listę ocen ucznia. Wprowadź metodę sredniaOcen(), która oblicza średnią ocen ucznia. Stwórz przypadek testowy.\nStwórz rekord Zamówienie, który zawiera listę produktów oraz ich cen. Każdy produkt reprezentowany jest przez rekord Produkt z nazwą i ceną. W rekordzie Zamówienie dodaj metodę calaWartosc(), która oblicza łączną wartość zamówienia na podstawie cen produktów. Stwórz przypadek testowy.\nStwórz rekord Osoba, który reprezentuje imię i wiek osoby. Dodaj konstruktor, który weryfikuje, czy podany wiek nie jest ujemny. W przypadku podania wartości ujemnej, ustaw wiek na 0. Stwórz przypadek testowy.\nStwórz rekord KontoBankowe, który zawiera numer konta oraz saldo. Dodaj konstruktor, który pozwala na tworzenie konta tylko z numerem, przy czym domyślne saldo wynosi 0. Stwórz przypadek testowy.\nStwórz rekord UtwórMuzyczny, który opisuje tytuł, artystę i czas trwania utworu w sekundach. Dodaj konstruktor, który przyjmuje tylko tytuł i artystę, przyjmując domyślną długość utworu jako 180 sekund. Stwórz przypadek testowy."
  },
  {
    "objectID": "dziedziczenie.html",
    "href": "dziedziczenie.html",
    "title": "15  Dziedziczenie",
    "section": "",
    "text": "Wykonaj kolejno poniższe czynności:\n\nStwórz klasę bazową Osoba z prywatnym polem imie oraz chronionym polem nazwisko. Następnie stwórz klasę Pracownik, która dziedziczy po klasie Osoba. W klasie Pracownik próbuj odnieść się do obu pól i zauważ, które z nich są dostępne.\nNa bazie klasy Osoba z poprzedniego podpunktu, stwórz metody dostępowe (gettery) dla obu pól. W klasie Pracownik stwórz metodę wyswietlDane, która korzysta z tych metod dostępowych, aby wypisać informacje o pracowniku. Zastanów się, dlaczego metody dostępowe są używane do dostępu do prywatnych pól.\n\nStwórz klasę bazową Ksiazka z prywatnym polem tytul oraz chronionym polem autor. Stwórz klasę potomną Ebook, która dziedziczy po klasie Ksiazka. W klasie Ebook spróbuj zmienić modyfikator dostępu dla obu pól z klasy bazowej. Zastanów się, dlaczego jedno z pól pozwala na to, a drugie nie.\nStwórz klasę Narzędzie z chronionym konstruktorem, który przyjmuje nazwę narzędzia. Następnie stwórz klasę potomną Młotek, która dziedziczy po klasie Narzędzie. W klasie Młotek stwórz konstruktor, który korzysta z konstruktora klasy bazowej. Zastanów się, dlaczego używając modyfikatora private dla konstruktora klasy bazowej, taki scenariusz nie byłby możliwy.\nStwórz dwa różne pakiety: zwierzeta i ssaki. W pakiecie zwierzeta stwórz klasę bazową Zwierze z chronionym polem gatunek i prywatnym polem wiek. W pakiecie ssaki stwórz klasę Pies, która dziedziczy po klasie Zwierze. Spróbuj odnieść się w klasie Pies do obu pól z klasy bazowej i zauważ, które z nich są dostępne. Uwzględnij, że modyfikator protected pozwala na dostęp do pól w klasach potomnych, ale tylko w obrębie tego samego pakietu.\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę bazową Pojazd z metodą jedz, która wypisuje “Pojazd jedzie”. Następnie stwórz klasę potomną Samochod, która przesłania metodę jedz tak, by wypisywała “Samochod jedzie”. Utwórz obiekt klasy Samochod i wywołaj jego metodę jedz, aby zaobserwować wynik.\nNa bazie klasy Pojazd z poprzedniego podpunktu, w klasie Samochod, przesłoń metodę jedz tak, by wywoływała oryginalną metodę z klasy bazowej i dodatkowo wypisywała informacje specyficzne dla klasy Samochod. Użyj słowa kluczowego super, aby wywołać metodę z klasy bazowej.\n\nStwórz klasę Kalkulator z metodą dodaj, która przyjmuje dwa argumenty typu int i zwraca ich sumę. Następnie stwórz klasę potomną KalkulatorRozszerzony, która przesłania metodę dodaj w taki sposób, by przyjmowała trzy argumenty typu int i zwracała ich sumę. Zastanów się, czy to faktycznie przesłanianie metody, czy może coś innego.\nStwórz klasę bazową Baza z metodą statyczną info, która wypisuje “To jest klasa bazowa”. Następnie stwórz klasę potomną Potomek i próbuj przesłonić metodę statyczną info tak, by wypisywała “To jest klasa potomna”. Zastanów się nad zachowaniem tak przesłoniętych metod i dlaczego takie przesłanianie jest inaczej traktowane.\nStwórz klasę bazową Komputer z chronioną metodą uruchom, która wypisuje “Komputer uruchomiony”. Stwórz klasę potomną Laptop, która próbuje przesłonić metodę uruchom, ale z modyfikatorem dostępu public. Spróbuj skompilować kod i zastanów się, dlaczego występują pewne ograniczenia w przesłanianiu metod pod względem modyfikatorów dostępu.\nStwórz klasę bazową o nazwie Pojazd z polami: marka i model. Klasa ta powinna posiadać konstruktor przyjmujący oba te parametry. Następnie stwórz klasę potomną o nazwie Samochod, która dziedziczy po klasie Pojazd. Klasa Samochod powinna posiadać dodatkowe pole liczbaDrzwi. Stwórz konstruktor dla klasy Samochod, który przyjmuje wszystkie trzy parametry i korzysta z konstruktora klasy bazowej. Stwórz przypadek testowy.\nStwórz klasę bazową o nazwie Zwierze z polem nazwa oraz konstruktor z domyślnym przypisaniem nazwy do “Nieznane”. Następnie stwórz klasę Pies, która dziedziczy po klasie Zwierze. Nie twórz w niej dodatkowego konstruktora. Sprawdź, jakie zwierzę zostanie utworzone, gdy stworzysz nową instancję klasy Pies.\nStwórz klasę bazową o nazwie Budynek z polami: wysokosc i kolor. Klasa ta powinna posiadać dwa konstruktory: jeden przyjmujący oba parametry i drugi bezparametrowy, który przypisuje domyślne wartości. Stwórz klasę potomną Dom z dodatkowym polem liczbaPokoi. Klasa Dom powinna posiadać konstruktor, który wykorzystuje przeciążony konstruktor klasy bazowej. Stwórz przypadek testowy.\nStwórz trzy klasy: Istota, Człowiek i Programista. Klasa Człowiek powinna dziedziczyć po klasie Istota, a klasa Programista po klasie Człowiek. W każdej z klas dodaj konstruktor, który wypisuje informację o tworzeniu instancji danej klasy. Stwórz instancję klasy Programista i zaobserwuj kolejność wywoływania konstruktorów.\nUtwórz klasę Pojazd z polami marka, model i rokProdukcji. Utwórz klasy Samochod i Motocykl, które dziedziczą po klasie Pojazd. Klasa Samochod powinna mieć dodatkowe pole liczbaDrzwi, a klasa Motocykl pole pojemnoscSilnika. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Pracownik z polami imie, nazwisko i placa. Utwórz klasy Programista i Tester, które dziedziczą po klasie Pracownik. Klasa Programista powinna mieć dodatkowe pole jezykProgramowania, a klasa Tester pole typTestowania. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Nieruchomosc z polami adres, metraż i cena. Utwórz klasy Dom i Mieszkanie, które dziedziczą po klasie Nieruchomosc. Klasa Dom powinna mieć dodatkowe pole liczbaPieter, a klasa Mieszkanie pole numerPietra. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę GraPlanszowa z polami nazwaGry, minLiczbaGraczy, maxLiczbaGraczy oraz zasadyGry (jako ArrayList typu String). Utwórz klasy GraEdukacyjna i GraStrategiczna, które dziedziczą po klasie GraPlanszowa. Klasa GraEdukacyjna powinna mieć dodatkowe pole przedmiot, a klasa GraStrategiczna pole czasTrwania. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Druzyna z polami nazwa, miasto oraz punkty (jako ArrayList typu Integer). Utwórz klasy DruzynaPilkarska i DruzynaSiatkarska, które dziedziczą po klasie Druzyna. Klasa DruzynaPilkarska powinna mieć dodatkowe pole pozycjaWRankingu, a klasa DruzynaSiatkarska pole liczbaZwyciestw. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Komputer z polami producent, model oraz cenyCzesci (jako ArrayList typu Double). Utwórz klasy Laptop i Stacjonarny, które dziedziczą po klasie Komputer. Klasa Laptop powinna mieć dodatkowe pole waga, a klasa Stacjonarny pole obudowa. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę AlbumMuzyczny z polami tytul, artysta oraz oceny (jako ArrayList typu Integer). Utwórz klasy AlbumRockowy i AlbumJazzowy, które dziedziczą po klasie AlbumMuzyczny. Klasa AlbumRockowy powinna mieć dodatkowe pole gatunekRocka, a klasa AlbumJazzowy pole gatunekJazzu. Dodaj konstruktory, metody gettery i settery, metodę toString() oraz equals() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody."
  },
  {
    "objectID": "klasyabstrakcyjne.html",
    "href": "klasyabstrakcyjne.html",
    "title": "16  Klasy abstrakcyjne",
    "section": "",
    "text": "Zdefiniuj abstrakcyjną klasę NarzedziePracy z polami nazwa typu String oraz rokProdukcji typu java.time.LocalDate. Dodaj metodę abstrakcyjną uzyj(), która będzie symulować użycie narzędzia. Następnie zdefiniuj klasy Mlotek, Srubokret i Pila, które dziedziczą po klasie NarzedziePracy i implementują metodę uzyj(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę.\nZdefiniuj abstrakcyjną klasę GrafikaKomputerowa z polami szerokosc, wysokosc typu int oraz nazwaPliku typu String. Dodaj abstrakcyjne metody wczytajPlik() i zapiszPlik(). Następnie zdefiniuj klasy Bitmapa i Wektor, które dziedziczą po klasie GrafikaKomputerowa i implementują metody wczytajPlik() oraz zapiszPlik(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę.\nZdefiniuj abstrakcyjną klasę UrządzenieElektroniczne z polami producent typu String, model typu String oraz rokProdukcji typu java.time.LocalDate. Dodaj abstrakcyjne metody włącz() i wyłącz(). Następnie zdefiniuj klasy Smartfon, Telewizor i Laptop, które dziedziczą po klasie UrządzenieElektroniczne i implementują metody włącz() oraz wyłącz(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę."
  },
  {
    "objectID": "final.html",
    "href": "final.html",
    "title": "17  Pola, metody, klasy finalne",
    "section": "",
    "text": "Wykonaj kolejno czynności:\n\nStwórz klasę Planeta z jednym polem finalnym nazwa. Spróbuj zmienić wartość pola nazwa po jego inicjalizacji. Przeanalizuj wynik.\nDodaj do klasy Planeta metodę zmienNazwe, która próbuje zmienić nazwę planety. Jaki jest wynik próby zmiany finalnego pola za pomocą metody?\n\nStwórz klasę Samochod z dwoma polami: marka (normalne pole) i VIN (pole finalne - Numer Identyfikacyjny Pojazdu). Stwórz kilka obiektów Samochod i spróbuj zmienić pole VIN dla każdego z nich. Przeanalizuj wynik.\nStwórz klasę Zawodnik z jednym polem finalnym nazwa oraz polem punkty. Stwórz tablicę zawodników i spróbuj zmienić pole nazwa dla jednego z zawodników. Przeanalizuj wynik.\nStwórz klasę Osoba z jednym polem finalnym PESEL. Następnie stwórz klasę Student, która dziedziczy po klasie Osoba. Czy możesz zmienić pole PESEL w klasie Student? Co się stanie, jeśli spróbujesz to zrobić? Przeanalizuj wyniki.\nStwórz klasę bazową Elektronika z metodą finalną włącz, która wypisuje “Urządzenie włączone”. Następnie stwórz klasę potomną Telewizor i spróbuj przesłonić metodę włącz. Zaobserwuj, co się dzieje.\nStwórz klasę Komputer z metodą finalną boot oraz zwykłą metodą uruchomAplikacje. W klasie potomnej Laptop, spróbuj przesłonić obie metody. Sprawdź, która z metod pozwoli się przesłonić, a której nie.\nUtwórz finalną klasę NiezmienneDane z pewnymi atrybutami i metodami. Następnie spróbuj stworzyć klasę potomną ZmienneDane, która dziedziczy po klasie NiezmienneDane. Zastanów się, dlaczego nie można dziedziczyć po klasie oznaczonej jako final.\nStwórz klasę Gra, która w swoim konstruktorze ma metodę finalną inicjuj (inicializującą pewne dane). Utwórz klasę potomną RPG, która próbuje dostosować konstruktor klasy bazowej. Upewnij się, że metoda inicjuj działa poprawnie, mimo że jest oznaczona jako final.\nUtwórz klasę StałaMatematyczna z finalnym polem PI, które jest inicjowane wartością 3.14159. W klasie potomnej StałaFizyczna, spróbuj stworzyć metodę, która próbuje zmienić wartość PI. Zastanów się, dlaczego wartość finalnego pola nie może zostać zmieniona po jego inicjalizacji."
  },
  {
    "objectID": "comparable.html",
    "href": "comparable.html",
    "title": "18  Interfejs Comparable",
    "section": "",
    "text": "Napisz klasę Student, która zawiera pola: imie (typu String), sredniaOcen (typu double) i rokUrodzenia (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Student były sortowane malejąco według średniej ocen. Stwórz listę 5 obiektów klasy Student i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Pracownik, która zawiera pola: imie (typu String), pensja (typu double) i dataZatrudnienia (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Pracownik były sortowane rosnąco według pensji. Stwórz listę 5 obiektów klasy Pracownik i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Klient, która zawiera pola: imie (typu String), nrKlienta (typu int) i ostatnieLogowanie (typu Date). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Klient były sortowane malejąco według daty ostatniego logowania. Stwórz listę 5 obiektów klasy Klient i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Produkt, która zawiera pola: nazwa (typu String), cena (typu double) i dataProdukcji (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Produkt były sortowane rosnąco według daty produkcji. Stwórz listę 5 obiektów klasy Produkt i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Osoba, która zawiera pola: imie (typu String), wzrost (typu int) i dataUrodzenia (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Osoba były sortowane malejąco według wzrostu. Stwórz listę 5 obiektów klasy Osoba i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Ksiazka, która zawiera pola: tytul (typu String), liczbaStron (typu int) i dataWydania (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Ksiazka były sortowane malejąco według liczby stron. Stwórz tablicę 4 obiektów klasy Ksiazka i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Samochod, która zawiera pola: marka (typu String), przebieg (typu int) i rokProdukcji (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Samochod były sortowane rosnąco według przebiegu. Stwórz tablicę 4 obiektów klasy Samochod i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę ProduktSpozywczy, która zawiera pola: nazwa (typu String), cena (typu double) i dataWaznosci (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy ProduktSpozywczy były sortowane rosnąco według daty ważności. Stwórz tablicę 4 obiektów klasy ProduktSpozywczy i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Muzyka, która zawiera pola: tytul (typu String), artysta (typu String) i rokWydania (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Muzyka były sortowane malejąco według roku wydania. Stwórz tablicę 4 obiektów klasy Muzyka i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Przedmiot, która zawiera pola: nazwa (typu String), waga (typu double) i cena (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Przedmiot były sortowane rosnąco według wagi. Stwórz tablicę 4 obiektów klasy Przedmiot i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Student, która zawiera pola: imie (typu String), sredniaOcen (typu double) i rokStudiow (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Student były sortowane według jednego kryterium: malejąco według średniej ocen, a przy równości sortowane były rosnąco według roku studiów. Stwórz tablicę 4 obiektów klasy Student i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Zamowienie, która zawiera pola: nazwaProduktu (typu String), ilosc (typu int) i cenaJednostkowa (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Zamowienie były sortowane według jednego kryterium: malejąco według ceny jednostkowej, a przy równości sortowane były rosnąco według ilości. Stwórz listę tablicową 4 obiektów klasy Zamowienie i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Klient, która zawiera pola: imie (typu String), saldo (typu double) i ostatnieZakupy (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Klient były sortowane według jednego kryterium: malejąco według salda, a przy równości sortowane były rosnąco według daty ostatnich zakupów. Stwórz listę tablicową 4 obiektów klasy Klient i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Kurs, która zawiera pola: nazwa (typu String), liczbaGodzin (typu int) i cena (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Kurs były sortowane według jednego kryterium: rosnąco według liczby godzin, a przy równości sortowane były malejąco według ceny. Stwórz tablicę 4 obiektów klasy Kurs i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Produkt, która zawiera pola: nazwa (typu String), cena (typu double) i dataWaznosci (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Produkt były sortowane według jednego kryterium: malejąco według daty ważności, a przy równości sortowane były rosnąco według ceny. Stwórz listę obiektów klasy Produkt i posortuj ją według sprecyzowanego kryterium. Następnie wyświetl posortowaną listę na ekranie.\nNapisz klasę Samochód, która zawiera pola: marka (typu String), model (typu String) i numerRejestracyjny (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Samochód były sortowane według jednego kryterium: rosnąco według długości numeru rejestracyjnego. Stwórz tablicę 4 obiektów klasy Samochód i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Pracownik, która zawiera pola: imie (typu String), nazwisko (typu String) i stanowisko (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Pracownik były sortowane według jednego kryterium: rosnąco według długości nazwiska. Stwórz listę tablicową 4 obiektów klasy Pracownik i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Film, która zawiera pola: tytuł (typu String), reżyser (typu String) i gatunek (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Film były sortowane według jednego kryterium: rosnąco według długości tytułu. Stwórz listę tablicową 4 obiektów klasy Film i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Książka, która zawiera pola: tytuł (typu String), autor (typu String) i dataWydania (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Książka były sortowane według jednego niestandardowego kryterium: rosnąco według roku wydania. Stwórz tablicę 4 obiektów klasy Książka i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Produkt, która zawiera pola: nazwa (typu String), cena (typu double) i dataProdukcji (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Produkt były sortowane według jednego niestandardowego kryterium: malejąco według roku produkcji. Stwórz listę tablicową 4 obiektów klasy Produkt i posortuj ją według sprecyzowanego kryterium.\nZdefiniuj klasę Klient, która będzie implementować generyczny interfejs Comparable. W klasie tej zadeklaruj prywatne pola nazwisko typu String oraz saldo typu double. Implementując metodę compareTo interfejsu Comparable, porównuj klientów na podstawie ich salda, a w przypadku takiego samego salda - na podstawie nazwiska. Następnie zdefiniuj klasę Firma dziedziczącą po klasie Klient. Klasa Firma ma dodatkowo posiadać prywatne pole liczbaPracownikow typu int. Implementując metodę compareTo interfejsu Comparable w klasie Firma, skorzystaj z metody compareTo zdefiniowanej w klasie Klient oraz, w razie potrzeby, uwzględnij pole liczbaPracownikow. Napisz program TestKlient, w którym utwórz listę 5 klientów i firm o nazwie listaKlientow posługując się klasą ArrayList. W składzie listy powinny wystąpić przynajmniej dwóch klientów o takim samym saldzie i różnym nazwisku oraz dwie firmy o takiej samej liczbie pracowników i różnym saldzie. Wyświetl zawartość listy listaKlientow, posortuj ją za pomocą instancyjnej metody sort z klasy ArrayList i ponownie wyświetl zawartość tej listy.\nZdefiniuj klasę Zwierze, która będzie implementować generyczny interfejs Comparable. W klasie tej zadeklaruj prywatne pola gatunek typu String oraz wiek typu int. Implementując metodę compareTo interfejsu Comparable, porównuj zwierzęta na podstawie ich wieku, a w przypadku takiego samego wieku - na podstawie gatunku. Następnie zdefiniuj klasę Pies dziedziczącą po klasie Zwierze. Klasa Pies ma dodatkowo posiadać prywatne pole rasa typu String. Implementując metodę compareTo interfejsu Comparable w klasie Pies, skorzystaj z metody compareTo zdefiniowanej w klasie Zwierze oraz, w razie potrzeby, uwzględnij pole rasa. Napisz program TestZwierze, w którym utwórz listę 5 zwierząt i psów o nazwie listaZwierzat posługując się klasą ArrayList. W składzie listy powinny wystąpić przynajmniej po 3 obiekty różnych typów."
  },
  {
    "objectID": "comparator.html",
    "href": "comparator.html",
    "title": "19  Interfejs Comparator",
    "section": "",
    "text": "Napisz klasę Osoba z polami imie (String), wiek (int) i wzrost (double). Napisz klasę implementującą interfejs Comparator, która porównuje osoby na podstawie wieku. Stwórz tablicę 5 osób i posortuj ją według wieku.\nNapisz klasę Produkt z polami nazwa (String), cena (double) i dataWaznosci (LocalDate). Napisz klasę implementującą interfejs Comparator, która porównuje produkty na podstawie daty ważności. Stwórz listę 5 produktów i posortuj ją według daty ważności.\nNapisz klasę Samochod z polami marka (String), rokProdukcji (int) i cena (double). Napisz klasę implementującą interfejs Comparator, która porównuje samochody na podstawie roku produkcji. Stwórz tablicę 5 samochodów i posortuj ją według roku produkcji.\nNapisz klasę Pracownik z polami imie (String), pensja (double) i dataZatrudnienia (LocalDate). Napisz klasę implementującą interfejs Comparator, która porównuje pracowników na podstawie pensji. Stwórz tablicę 5 pracowników i posortuj ją według pensji.\nNapisz klasę Ksiazka z polami tytul (String), cena (double) i dataWydania (Date). Napisz klasę implementującą interfejs Comparator, która porównuje książki na podstawie daty wydania. Stwórz listę 5 książek i posortuj ją według daty wydania.\nNapisz klasę Product z polami id (typu int), name (typu String) oraz price (typu double). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu price (od najniższej do najwyższej ceny), a w przypadku równości po polu id. Stwórz listę 5 obiektów klasy Product i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Person z polami firstName (typu String), lastName (typu String) oraz birthDate (typu LocalDate). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu lastName (alfabetycznie od A do Z), a w przypadku równości po polu firstName. Stwórz tablicę 5 obiektów klasy Person i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Order z polami id (typu int), customerName (typu String) oraz orderDate (typu LocalDate). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu orderDate (od najwcześniejszej do najpóźniejszej daty), a w przypadku równości po polu id. Stwórz listę 5 obiektów klasy Order i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Song z polami title (typu String), artist (typu String) oraz duration (typu int). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu duration (od najkrótszej do najdłuższej piosenki), a w przypadku równości po polu title. Stwórz tablicę 5 obiektów klasy Song i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Student z polami id (typu int), name (typu String) oraz averageGrade (typu double). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu averageGrade (od najwyższej do najniższej średniej ocen), a w przypadku równości po polu name. Stwórz listę 5 obiektów klasy Student i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Product z polami id (typu int), name (typu String) oraz price (typu double). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: PriceComparator do porównywania obiektów po polu price (od najniższej do najwyższej ceny) oraz NameComparator do porównywania obiektów po polu name (alfabetycznie od A do Z). Stwórz listę 5 obiektów klasy Product i posortuj ją zgodnie z oboma kryteriami (najpierw po cenie, a następnie po nazwie).\nNapisz klasę Person z polami firstName (typu String), lastName (typu String) oraz birthDate (typu LocalDate). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: LastNameComparator do porównywania obiektów po polu lastName (alfabetycznie od A do Z) oraz BirthDateComparator do porównywania obiektów po polu birthDate (od najstarszej do najmłodszej osoby). Stwórz tablicę 5 obiektów klasy Person i posortuj ją zgodnie z oboma kryteriami (najpierw po nazwisku, a następnie po dacie urodzenia).\nNapisz klasę Order z polami id (typu int), customerName (typu String) oraz orderDate (typu LocalDate). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: OrderDateComparator do porównywania obiektów po polu orderDate (od najwcześniejszej do najpóźniejszej daty) oraz CustomerNameComparator do porównywania obiektów po polu customerName (alfabetycznie od A do Z). Stwórz listę 5 obiektów klasy Order i posortuj ją zgodnie z oboma kryteriami (najpierw po dacie zamówienia, a następnie po nazwie klienta).\nNapisz klasę Song z polami title (typu String), artist (typu String) oraz duration (typu int). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: DurationComparator do porównywania obiektów po polu duration (od najkrótszej do najdłuższej piosenki) oraz ArtistTitleComparator do porównywania obiektów po polu artist (alfabetycznie od A do Z) i w przypadku równości po polu title. Stwórz tablicę 5 obiektów klasy Song i posortuj ją zgodnie z oboma kryteriami (najpierw po długości utworu,a następnie po artyście i tytule).\nNapisz klasę Student z polami id (typu int), name (typu String) oraz averageGrade (typu double). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: AverageGradeComparator do porównywania obiektów po polu averageGrade (od najwyższej do najniższej średniej ocen) oraz IdComparator do porównywania obiektów po polu id (od najniższego do najwyższego identyfikatora). Stwórz listę 5 obiektów klasy Student i posortuj ją zgodnie z oboma kryteriami (najpierw po średniej ocen, a następnie po identyfikatorze)."
  },
  {
    "objectID": "kopiowanie.html",
    "href": "kopiowanie.html",
    "title": "20  Kopiowanie obiektów",
    "section": "",
    "text": "Napisz klasę Student z trzema polami: name (String), age (int) i grade (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Student, sklonuj go, a następnie zmień ocenę (grade) oryginalnego studenta. Wyświetl oceny obu studentów, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z trzema polami: name (String), subject (String) i experience (int). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień doświadczenie (experience) oryginalnego nauczyciela. Wyświetl doświadczenie obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Car z trzema polami: make (String), model (String) i mileage (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Car, sklonuj go, a następnie zmień przebieg (mileage) oryginalnego samochodu. Wyświetl przebieg obu samochodów, aby zobaczyć, czy są niezależne.\nNapisz klasę Smartphone z trzema polami: brand (String), model (String) i productionDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Smartphone, sklonuj go, a następnie zmień datę produkcji oryginalnego smartfona. Wyświetl datę produkcji obu smartfonów, aby zobaczyć, czy są niezależne.\nNapisz klasę Laptop z trzema polami: brand (String), model (String) i purchaseDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Laptop, sklonuj go, a następnie zmień datę zakupu (purchaseDate) oryginalnego laptopa. Wyświetl datę zakupu obu laptopów, aby zobaczyć, czy są niezależne.\nNapisz klasę VideoGame z trzema polami: title (String), genre (String) i releaseDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt VideoGame, sklonuj go, a następnie zmień datę wydania (releaseDate) oryginalnej gry. Wyświetl datę wydania obu gier, aby zobaczyć, czy są niezależne.\nNapisz klasę CreditCard z trzema polami: cardNumber (String), holderName (String) i expiryDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt CreditCard, sklonuj go, a następnie zmień datę wygaśnięcia (expiryDate) oryginalnej karty kredytowej. Wyświetl datę wygaśnięcia obu kart, aby zobaczyć, czy są niezależne.\nNapisz klasę BankAccount z trzema polami: accountNumber (String), accountHolder (String) i openingDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt BankAccount, sklonuj go, a następnie zmień datę otwarcia (openingDate) oryginalnego konta bankowego. Wyświetl datę otwarcia obu kont, aby zobaczyć, czy są niezależne.\nNapisz klasę DrivingLicense z trzema polami: licenseNumber (String), holderName (String) i issueDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt DrivingLicense, sklonuj go, a następnie zmień datę wydania (issueDate) oryginalnego prawa jazdy. Wyświetl datę wydania obu praw jazdy, aby zobaczyć, czy są niezależne.\nNapisz klasę Employee z dwoma polami: name (String) i salaries (tablica 12 zmiennych typu double, reprezentująca zarobki za każdy miesiąc). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Employee, sklonuj go, a następnie zmień zarobki na pozycji 5 (czerwiec) oryginalnego pracownika. Wyświetl zarobki obu pracowników, aby zobaczyć, czy są niezależne.\nNapisz klasę Athlete z dwoma polami: name (String) i times (tablica 5 zmiennych typu double, reprezentująca czas w sekundach potrzebny na przebiegnięcie 100 metrów podczas różnych prób). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Athlete, sklonuj go, a następnie zmień czas na pozycji 3 oryginalnego sportowca. Wyświetl czasy obu sportowców, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z dwoma polami: name (String) i studentsGrades (tablica 10 zmiennych typu double, reprezentująca oceny każdego z 10 uczniów). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień ocenę na pozycji 10 oryginalnego nauczyciela. Wyświetl oceny obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Employee z dwoma polami: name (String) i monthlyHours (lista tablicowa zmiennych typu int, reprezentująca liczbę przepracowanych godzin w każdym miesiącu). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Employee, sklonuj go, a następnie zmień liczbę godzin na pozycji 5 (czerwiec) oryginalnego pracownika. Wyświetl liczbę godzin obu pracowników, aby zobaczyć, czy są niezależne.\nNapisz klasę Athlete z dwoma polami: name (String) i lapTimes (lista tablicowa zmiennych typu int, reprezentująca czas w sekundach potrzebny na przebiegnięcie okrążenia podczas różnych prób). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Athlete, sklonuj go, a następnie zmień czas na pozycji 3 oryginalnego sportowca. Wyświetl czasy obu sportowców, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z dwoma polami: name (String) i studentsGrades (lista tablicowa zmiennych typu int, reprezentująca oceny każdego z uczniów). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień ocenę na pozycji 10 oryginalnego nauczyciela. Wyświetl oceny obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z polami name (String), age (int) i salary (double). Następnie napisz klasę HeadTeacher, która dziedziczy po klasie Teacher i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas.\nNapisz klasę Developer z polami name (String), age (int) i salary (double). Następnie napisz klasę SeniorDeveloper, która dziedziczy po klasie Developer i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas.\nNapisz klasę Nurse z polami name (String), age (int) i salary (double). Następnie napisz klasę HeadNurse, która dziedziczy po klasie Nurse i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas."
  },
  {
    "objectID": "interfejsy.html",
    "href": "interfejsy.html",
    "title": "21  Interfejsy",
    "section": "",
    "text": "Napisz interfejs o nazwie GłośneZwierzę, który będzie miał jedną metodę o nazwie dajGłos(). Następnie stwórz dwie klasy: Pies i Kot, które będą implementować ten interfejs. Dla każdej klasy zaimplementuj metodę dajGłos(), tak aby wydrukowała ona odpowiedni dźwięk zwierzęcia.\nStwórz interfejs o nazwie Komparator, który będzie zawierał metodę porównaj(int a, int b): int. Metoda ta powinna zwrócić -1, jeśli a &lt; b, 0 jeśli a == b i 1 jeśli a &gt; b. Następnie stwórz klasę MojaKlasaKomparatora, która będzie implementować ten interfejs. W klasie tej zaimplementuj metodę porównaj zgodnie z jej opisem.\nZałóżmy, że mamy interfejs OdtwarzaczMuzyki z metodami włącz(), wyłącz() i następnyUtwór(). Stwórz klasę Radio, która będzie implementować ten interfejs. W metodzie włącz() powinien zostać wydrukowany komunikat “Radio włączone”, w metodzie wyłącz() - “Radio wyłączone”, a w następnyUtwór() - “Zmieniono stację radiową”."
  },
  {
    "objectID": "delegacje.html",
    "href": "delegacje.html",
    "title": "22  Delegacje",
    "section": "",
    "text": "Wykonaj poniższe czynności:\n\n\nStwórz interfejs Printer z metodą drukuj(String tekst).\nUtwórz klasę StandardowyPrinter, która implementuje Printer i wypisuje tekst na konsolę.\nUtwórz klasę Biuro, która posiada prywatne pole typu Printer. W konstruktorze Biuro przyjmij Printer jako argument i przypisz go do pola. Dodaj metodę drukujDokument(String tekst), która będzie delegować zadanie drukowania do obiektu klasy Printer.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs Silnik z metodami uruchom() i zatrzymaj().\nUtwórz klasę BenzynowySilnik, która implementuje Silnik i symuluje działanie silnika na benzynę.\nUtwórz klasę Samochód, która posiada prywatne pole typu Silnik. W konstruktorze przyjmij Silnik jako argument. Dodaj metody start() i stop(), które będą delegować odpowiednio zadanie uruchomienia i zatrzymania silnika do obiektu klasy Silnik.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs Powiadomienie z metodą wyślij(String wiadomość).\nUtwórz klasę Email, która implementuje Powiadomienie i symuluje wysyłanie wiadomości e-mail.\nUtwórz klasę Użytkownik, która posiada prywatne pole typu Powiadomienie. W konstruktorze przyjmij Powiadomienie jako argument. Dodaj metodę powiadomOModernizacji(String informacja), która będzie delegować zadanie wysyłania powiadomienia do obiektu klasy Powiadomienie."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliografia i inne zbiory zadań",
    "section": "",
    "text": "Kozak, Jan. n.d. Materiały Do Ćwiczeń. Accessed July 16, 2023.\nhttp://www.jkozak.pl/przedmioty/podstawy-i-jezyki-programowania/materialy-do-cwiczen/.\n\n\nRychlicki, Wiesław. 2012. Programowanie w Języku Java. Zbiór Zadań z\n(p)odpowiedziami. Helion."
  }
]