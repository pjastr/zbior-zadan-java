[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zbiór zadań - Java",
    "section": "",
    "text": "Zbiór zadań - Java\nTu będzie zbiór zadań z programowania w języku Java. Inspiracją było zebranie zadań powstałych w trakcie prowadzenia zajęć dydaktycznych realizowanych na Wydziale Matematyki i Informatyki Uniwersytetu Warmińsko-Mazurskiego w Olsztynie.\nRozwiązania wybranych zadań dostępne są tutaj.\nZmiany:\n10.10.2023 - uzupełniono zadania dot tablic, list tablicowych, napisów\n11.10.2023 - drobne poprawki w zadaniach dot. metod\n16.10.2023 - dodano przypisy do wybranych “problematycznych” sformułowań niektórych zadań.\n17.10.2023 - poprawka przypisu, poprawa niektórych zadań\n24.10.2023 - poprawki zadań dot. klas, obiektów i modyfikatorów dostępu\n29.10.2023 - zmiana nazw na angielski w części dot. modyfikatorów dostępu, konstruktora, pól i metod statycznych, dziedziczenia; dodano sekcję “Metody toString i equals” oraz Pakiety\n10.11.2023 - dodano logo\n11.11.2023 - zmiana nazw na angielski w części dot. rekordów\n12.11.2023 - uzupełnienie w sposób jawny o metodę hasCode, zmiana nazw na angielski w części dot. dziedziczenia, złożonych pół w klasie, klas abstrakcyjnych\n19.11.2023 - dodanie kilku zadań dot. dziedziczenia\n3.12.2023 - poprawki w final i złożonych polach w klasie\n10.12.2023 - poprawki i uzupełnienia w interfejsach\n\n\n\n\nKozak, Jan. b.d. Materiały do ćwiczeń. Dostęp 16 lipiec 2023. http://www.jkozak.pl/przedmioty/podstawy-i-jezyki-programowania/materialy-do-cwiczen/.\n\n\nRychlicki, Wiesław. 2012. Programowanie w języku Java. Zbiór zadań z (p)odpowiedziami. Helion."
  },
  {
    "objectID": "wejsciewyjscie.html",
    "href": "wejsciewyjscie.html",
    "title": "1  Operacje wejścia/wyjścia",
    "section": "",
    "text": "Napisz prostą aplikację kalkulatora tekstowego, która przyjmuje dwa liczby od użytkownika jako wejście i wykonuje podstawowe operacje matematyczne (dodawanie, odejmowanie, mnożenie, dzielenie). Wyświetl wyniki na ekranie.\nNapisz program, który wczytuje ze standardowego wejścia dwa łańcuchy znaków, a następnie wypisuje je w kolejnych wierszach na standardowym wyjściu.\nNapisz program, który wczytuje ze standardowego wejścia cztery liczby wymierne, a następnie wypisuje ich sumę na standardowym wyjściu.\nStwórz program do obliczenia pola kwadratu. Dane pobierz od użytkownika, wynik wyświetl na standardowym wyjściu.\nNapisz program, w którym wartości zmiennych pobierasz od użytkownika i wykonasz i wyświetlisz wyniki operacji:\n\n\n\\(a+b-x^2\\)\n\\(\\frac{a-b}{c-3}\\)\n\\(3(4+5a)(b-c^3)\\)\n\n\nNapisz program, w którym zostaną wykonane poniższe operacje za pomocą tzw. złożonych operatorów przypisania (+= , -= i innych podobnych operatorów):\n\n\n\\(a=a+4\\)\n\\(b=b-a\\)\n\\(c=c(2-4a)\\)\n\\(d=\\frac{d}{4-a^2}\\)"
  },
  {
    "objectID": "instrukcjewarunkowe.html",
    "href": "instrukcjewarunkowe.html",
    "title": "2  Instrukcje warunkowe",
    "section": "",
    "text": "Napisz program, który sprawdza, czy podana liczba całkowita jest parzysta. Jeżeli tak, program powinien wypisać “Liczba jest parzysta”, w przeciwnym razie “Liczba jest nieparzysta”.\nNapisz program, który przyjmuje trzy liczby całkowite jako argumenty i zwraca największą z nich. Zastosuj instrukcje warunkowe do porównania liczb.\nNapisz program, który na podstawie podanego jako argument numeru dnia tygodnia (od 1 do 7) wypisze nazwę tego dnia tygodnia. Dla przykładu, jeżeli użytkownik poda liczbę 1, program powinien wypisać “Poniedziałek”. Jeżeli podana liczba nie jest z zakresu od 1 do 7, program powinien wyświetlić komunikat “Niepoprawny numer dnia tygodnia”.\nNapisz program, który rozwiązuje równanie kwadratowe o postaci \\(ax^2 + bx + c = 0\\). Program powinien przyjmować jako argumenty wartości \\(a\\), \\(b\\), i \\(c\\), obliczać delty (\\(b^2 - 4ac\\)), a następnie zwracać rozwiązania równania w zależności od wartości delty.\nNapisz program, który przyjmuje wiek użytkownika jako argument. Jeżeli wiek jest mniejszy niż 18, program powinien wyświetlić “Jesteś niepełnoletni”. Jeżeli wiek jest większy lub równy 18, ale mniejszy od 65, program powinien wyświetlić “Jesteś dorosły”. Jeżeli wiek jest równy lub większy niż 65, program powinien wyświetlić “Jesteś emerytem”.\nNapisz program, który będzie sprawdzał, czy podany rok jest rokiem przestępnym. Rok jest przestępny, jeśli jest podzielny przez 4, ale nie jest podzielny przez 100, chyba że jest podzielny przez 400.\nNapisz program, który przyjmuje trzy liczby całkowite jako argumenty i sortuje je w kolejności rosnącej, używając instrukcji warunkowych, a następnie wyświetla posortowane liczby.\nNapisz program, który oblicza podatek dochodowy na podstawie podanych dochodów i zasad podatkowych. Załóżmy, że podatek wynosi 18% dla dochodu do 85,528 PLN, a dla dochodu powyżej tej kwoty podatek wynosi 14,839.02 PLN plus 32% nadwyżki ponad 85,528 PLN. Użytkownik powinien wprowadzić swoje dochody, a program powinien obliczyć i wyświetlić kwotę podatku.\nNapisz program sprawdzający czy podane liczby z klawiatury mogą stanowić poprawną datę w kalendarzu.\n\nPrzykładowe wejście:\nPodaj dzień: 29\nPodaj miesiąc: 2\nPodaj rok: 2017\nPrzykładowe wyjście:\nBłędna data\n\nNapisz program sprawdzający czy podane liczby z klawiatury mogą stanowić poprawna godzinę w formacie 24-godzinnym.\n\nPrzykładowe wejście:\nPodaj godzinę: 22\nPodaj minuty: 12\nPodaj sekundy: 33\nPrzykładowe wyjście:\nPoprawna godzina!\n\nNapisz program, w którym użytkownik ma wprowadzić trzycyfrową liczbę całkowitą. Następnie należy sprawdzić czy liczba jest palindromem. Stosowny komunikat wyświetl na konsoli.\nNapisz program, który pobiera trzy liczby całkowite (teoretycznie mogą być różnych znaków) i sprawdza, czy można z nich zbudować trójkąt prostokątny - ostatecznie wypisuje „TAK” lub „NIE”."
  },
  {
    "objectID": "petle.html",
    "href": "petle.html",
    "title": "3  Pętle",
    "section": "",
    "text": "Napisz program, który wykorzystując pętlę for wyświetli liczby od 1 do 100.\nNapisz program, który przy użyciu pętli while obliczy sumę liczb od 1 do 50.\nNapisz program w Javie, który za pomocą pętli for generuje pierwsze 10 liczb ciągu Fibonacciego.\nStwórz program, który używając zagnieżdżonych pętli for, wyświetli tabliczkę mnożenia dla liczb od 1 do 10.\nNapisz program, który używając pętli do-while, wyświetli pierwsze 20 liczb parzystych i nieparzystych.\nNapisz program, który sprawdzi, czy podana liczba jest liczbą pierwszą. Liczba powinna być wprowadzona przez użytkownika.\nNapisz program, który oblicza sumę cyfr dowolnej wprowadzonej liczby. Program powinien akceptować liczbę jako input od użytkownika.\nNapisz program, który generuje i wyświetla pierwsze 10 elementów szeregu geometrycznego o zadanym pierwszym elemencie i ilorazie. Parametry szeregu powinny być wprowadzane przez użytkownika.\nStwórz program, który przyjmie od użytkownika liczbę całkowitą i zwróci tę liczbę w odwrotnej kolejności. Na przykład, dla liczby 12345, wynik powinien wynosić 54321. Możesz ograniczyć program tylko do liczb dodatnich.\nNapisz program, który obliczy sumę kwadratów liczb od 1 do n, gdzie n jest liczbą wprowadzoną przez użytkownika.\nNapisz program, który znajdzie i wyświetli wszystkie liczby doskonałe mniejsze od 10 000. Liczba doskonała to taka, której suma dzielników (bez niej samej) jest równa jej wartości. Na przykład, 6 jest liczbą doskonałą, ponieważ \\(1 + 2 + 3 = 6\\).\nNapisz program, który znajdzie wszystkie liczby Amstronga mniejsze od 10 000. Liczba Amstronga to taka, której suma jej cyfr podniesionych do potęgi równiej liczbie cyfr w tej liczbie, jest równa samej liczbie. Na przykład 153 jest liczbą Amstronga, ponieważ \\(1^3 + 5^3 + 3^3 = 153\\).\nNapisz program, który dla dwóch podanych liczb obliczy ich najmniejszą wspólną wielokrotność (NWW). Użytkownik powinien podać dwie liczby jako dane wejściowe.\nNapisz program pobierający z klawiatury liczbę całkowitą dodatnią. Następnie narysuj odpowiedni trójkąt np. dla 5:\n\n1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n\nNapisz program, który pobiera od użytkownika liczbę naturalną \\(n\\) (\\(n\\geqslant 0\\)). Następnie wyznacz i wyświetl \\(n\\)-ty element ciągu:\n\n\n\n\\((4,-8,16,-32,64,\\ldots )\\)\n\\((2,6,18,54,162,\\ldots )\\)\n\\((8,3,-2,-7,-12,\\ldots )\\)\n\n\n\nNapisz program wczytujący kolejne liczby całkowite (różnych znaków) z klawiatury i kończący się gdy ich suma przekroczy 100.\nNapisz program, który pobiera od użytkownika dodatnią liczbę całkowitą \\(n\\), następnie \\(n\\) liczb całkowitych \\(a_1, \\ldots, a_n\\). Program ma wyświetlić ile spośród tych liczb spełnia warunek \\(3^k &lt; a_k &lt;k!\\) dla \\(1\\leq k \\leq n\\).\nNapisać program wyświetlający na ekranie pierwsze szesnaście potęg dwójki. Wykorzystaj w tym celu pętle.\nNapisz program, który pobiera od użytkownika 5 liczb całkowitych. Pobieranie ma zostać przerwane, gdy użytkownik wprowadzić liczbę ujemną. Jeśli pobieranie nie zostanie przerwane, wyświetl sumę wprowadzonych liczb.\nNapisz program, który wczytuje ze standardowego wejścia dwie liczby całkowite \\(n\\) i \\(m\\) (zakładamy, że \\(n &lt; m\\)) i wypisuje na standardowym wyjściu wartość liczby \\(n\\cdot \\ldots \\cdot m\\).\nNapisz program, który wczytuje ze standardowego wejścia dwie liczby całkowite \\(n\\) i \\(m\\) (zakładamy, że \\(n &lt; m\\)) i wypisuje na standardowym wyjściu wartość liczby \\(n+ \\ldots + m\\).\nNapisz program, który pobiera od użytkownika trzy dodatnie liczby całkowite \\(a, b, c\\). Na standardowym wyjściu wyświetl dodatnie liczby całkowite większe od \\(b\\), mniejsze lub równe od \\(a\\) i podzielne przez \\(c\\).\nNapisz program, który ze standardowego wejścia pobiera liczbę naturalną \\(a\\) a następnie wypisuje na standardowym wyjściu ile z cyfr liczby \\(a\\) jest równe 7.\nNapisać program, który wczyta z wejścia liczby całkowite aż do napotkania liczby ujemnej, a następnie wyświetla największy oraz najmniejszy element z wczytanych liczb (z pominięciem ostatniej, ujemnej liczby)."
  },
  {
    "objectID": "metody.html#footnotes",
    "href": "metody.html#footnotes",
    "title": "4  Funkcje/metody",
    "section": "",
    "text": "Te zadanie nie ma w błędu w formułowaniu. Takich liczb nie ma, jednak pod kątem teoretycznym można zastanowić się które warunki należałoby spełnić i jak je zakodować.↩︎"
  },
  {
    "objectID": "random.html",
    "href": "random.html",
    "title": "5  Generowanie liczb pseudolosowych",
    "section": "",
    "text": "Napisz metodę generateRandomInt, która generuje i zwraca losową liczbę całkowitą. Stwórz przypadek testowy.\nNapisz metodę generateRandomDouble, która generuje i zwraca losową liczbę zmiennoprzecinkową z zakresu od 0.0 do 1.0. Stwórz przypadek testowy.\nNapisz metodę generateRandomIntInRange, która przyjmuje dwie liczby całkowite jako argumenty i zwraca losową liczbę całkowitą z tego zakresu (włącznie z granicami). Na przykład, dla argumentów 5 i 10, metoda powinna zwracać liczbę z zakresu od 5 do 10. Stwórz przypadek testowy.\nNapisz metodę generateRandomGaussian, która generuje i zwraca losową liczbę zmiennoprzecinkową zgodnie z rozkładem normalnym. Stwórz przypadek testowy.\nNapisz metodę generateRandomBoolean, która generuje i zwraca losową wartość logiczną (true lub false). Stwórz przypadek testowy."
  },
  {
    "objectID": "tablice.html#footnotes",
    "href": "tablice.html#footnotes",
    "title": "6  Tablice",
    "section": "",
    "text": "Zadanie zostało nieco poprawione. Stara wersja polecenia: Napisz statyczną metodę reverseArray, która przyjmuje tablicę liczb całkowitych jako argument i zwraca tę samą tablicę, ale z odwróconym porządkiem elementów. Na przykład, dla tablicy [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.↩︎"
  },
  {
    "objectID": "arraylist.html#footnotes",
    "href": "arraylist.html#footnotes",
    "title": "7  ArrayList (listy tablicowe)",
    "section": "",
    "text": "Stara wersja polecenia: Napisz statyczną metodę reverseArray, która przyjmuje listę tablicową liczb całkowitych jako argument i zwraca tę samą listę tablicową, ale z odwróconym porządkiem elementów. Na przykład, dla [1, 2, 3, 4, 5], funkcja powinna zwrócić [5, 4, 3, 2, 1]. Stwórz przypadek testowy.↩︎"
  },
  {
    "objectID": "napisy.html",
    "href": "napisy.html",
    "title": "8  Napisy",
    "section": "",
    "text": "Napisz statyczną metodę, która przyjmuje napis jako argument i zwraca ten napis w odwrotnej kolejności. Stwórz przypadek testowy.\nNapisz statyczną metodę, która sprawdza, czy dany napis jest palindromem. Palindrom to słowo, fraza, liczba lub inny ciąg znaków, który czyta się tak samo od przodu, jak i od tyłu. Stwórz przypadek testowy.\nNapisz statyczną metodę, która usuwa wszystkie spacje z danego napisu. Stwórz przypadek testowy.\nNapisz statyczną metodę, która przyjmuje napis jako argument i zwraca ten napis z zamienioną pierwszą i ostatnią literą. Stwórz przypadek testowy.\nNapisz program, który analizuje dany napis pod kątem częstotliwości występowania każdego ze znaków. Program powinien wyświetlić znak i liczbę jego wystąpień w danym napisie. Dane pobierz ze standardowego wejścia.\nNapisz program, który przyjmuje napis jako wejście i wypisuje wszystkie znaki znajdujące się na parzystych indeksach napisu, używając metody charAt.\nUżywając metody charAt, napisz statyczną metodę, która sprawdza, czy dany napis zaczyna się i kończy tym samym znakiem. Stwórz przypadek testowy.\nNapisz program, który przyjmuje trzy napisy: główny napis, prefiks i sufiks. Używając metod startsWith oraz endsWith, sprawdź czy główny napis zaczyna się od podanego prefiksu i kończy podanym sufiksem. Wypisz odpowiedni komunikat dla każdego z tych przypadków.\nNapisz program, który przyjmuje jako wejście pojedynczy znak oraz liczbę całkowitą n. Używając klasy StringBuilder, zbuduj i wypisz piramidę o wysokości n, gdzie każdy poziom piramidy składa się z podanego znaku. Na przykład dla znaku * i n=3, oczekiwany wynik to:\n\n *\n***\n*****\n\nDany jest napis. Używając StringBuilder, napisz program, który usuwa wszystkie powtarzające się znaki, pozostawiając tylko pierwsze wystąpienie każdego znaku. Na przykład dla napisu “bananowy”, oczekiwany wynik to “banowy”.\nNapisz program, który przyjmuje zdanie jako wejście. Używając StringBuilder, odwróć każde słowo w zdaniu, ale zachowaj kolejność słów. Na przykład dla zdania “Java jest fajna”, oczekiwany wynik to “avaJ tsej anjaf”.\nNapisz metodę statyczną reverseString, która przyjmuje jako argument obiekt typu StringBuilder i zwraca nowy StringBuilder, będący odwróconym napisem pierwotnym. Stwórz przypadek testowy.\nNapisz metodę statyczną removeDuplicates, która przyjmuje StringBuilder i usuwa wszystkie powtarzające się znaki w napisie, pozostawiając tylko pierwsze wystąpienie danego znaku. Stwórz przypadek testowy.\nNapisz metodę statyczną mostFrequentChar, która przyjmuje StringBuilder jako argument i zwraca znak, który występuje najczęściej w napisie. W przypadku remisów, zwróć pierwszy znak z remisowych. Stwórz przypadek testowy.\nNapisz metodę statyczną insertSubstring, która przyjmuje dwa argumenty: StringBuilder sb oraz String toInsert. Metoda ma wstawiać toInsert w środek pierwotnego StringBuilder. Stwórz przypadek testowy.\nNapisz metodę statyczną splitByEvenOdd, która przyjmuje StringBuilder jako argument. Metoda powinna zwracać tablicę dwóch elementów typu StringBuilder. Pierwszy element tablicy ma zawierać znaki z nieparzystych indeksów pierwotnego napisu, a drugi z parzystych. Stwórz przypadek testowy.\nNapisz metodę statyczną capitalizeEverySecond, która przyjmuje jako argument obiekt typu StringBuffer. Metoda ma zmienić każdą drugą literę na wielką. Stwórz przypadek testowy.\nNapisz metodę statyczną replaceSubstring, która przyjmuje dwa argumenty: StringBuffer sb i String oldSub, oraz String newSub. Metoda ma zamienić wszystkie wystąpienia podciągu oldSub na newSub. Stwórz przypadek testowy.\nNapisz metodę statyczną countOccurrences, która przyjmuje dwa argumenty: StringBuffer sb oraz char c. Metoda powinna zwracać liczbę wystąpień znaku c w napisie. Stwórz przypadek testowy.\nNapisz metodę statyczną trimToSize, która przyjmuje StringBuffer sb i liczbę całkowitą n. Metoda ma zmniejszyć długość napisu do n znaków (jeśli pierwotny napis jest dłuższy). Jeśli napis jest krótszy lub równy n, nie powinien ulec zmianie. Stwórz przypadek testowy.\nNapisz metodę statyczną isPalindrome, która przyjmuje StringBuffer jako argument. Metoda powinna sprawdzić, czy napis jest palindromem (odczytywany tak samo od przodu jak i od tyłu) i zwrócić odpowiednią wartość logiczną. Stwórz przypadek testowy."
  },
  {
    "objectID": "klasaobiekt.html",
    "href": "klasaobiekt.html",
    "title": "9  Pojęcie klasy/obiektu",
    "section": "",
    "text": "Utwórz klasę Dog z polami: name, breed i age. Napisz metodę bark(), która wydrukuje na konsoli \"Wow Wow\". Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nStwórz klasę Car z polami: brand, model i speed. Napisz metody accelerate(int value) i decelerate(int value), które odpowiednio zwiększają i zmniejszają prędkość o podaną wartość. Stwórz przypadek testowy, aby wywołać każdą metodę co najmniej jeden raz.\nStwórz klasę BankAccount z polem balance. Napisz metody deposit(double amount) i withdraw(double amount), które odpowiednio zwiększają i zmniejszają saldo o daną kwotę. Stwórz przypadek testowy, aby wywołać każdą metodę co najmniej jeden raz.\nUtwórz klasę Point z dwoma polami: x i y reprezentującymi współrzędne na płaszczyźnie. Napisz metodę distance(Point otherPoint), która oblicza odległość między bieżącym punktem a innym punktem. Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nStwórz klasę Time z polami: hours i minutes. Napisz metodę addTime(Time otherTime), która dodaje do bieżącego czasu czas podany jako argument i zwraca nowy obiekt klasy Time. Zadbaj o to, aby minuty i godziny nie przekraczały odpowiednio 59 i 23. Stwórz przypadek testowy, aby wywołać metodę co najmniej jeden raz.\nWykonaj po kolei dwa podpunkty:\nA. Stwórz klasę Car zawierającą publiczne pole brand. W klasie TestCar, utwórz obiekt klasy Car, przypisz mu wartość null i spróbuj odwołać się do pola brand. Jaki jest wynik?\nB. Zmodyfikuj kod z podpunktu A tak, aby sprawdzić, czy obiekt Car jest null przed odwołaniem się do pola brand. Jaki jest wynik?\nUtwórz klasę Person zawierającą pole name. W klasie TestPerson, utwórz dwa obiekty klasy Person - person1 i person2 - oba odnoszące się do tego samego obiektu. Zmień wartość pola name przez person1 i wydrukuj wartość pola name przez person2. Przeanalizuj wynik.\nStwórz tablicę obiektów klasy Car (klasa zawiera publiczne pole brand). Następnie spróbuj odwołać się do pola brand jednego z obiektów w tablicy, nie inicjalizując wcześniej tablicy obiektami Car. Przeanalizuj wynik.\nStwórz listę tablicową (ArrayList) obiektów klasy Person (klasa zawiera publiczne pole name). Następnie spróbuj odwołać się do pola name jednego z obiektów na liście, nie dodając wcześniej do listy żadnych obiektów Person. Przeanalizuj wynik.\nUtwórz klasę Dog z metodą bark, która wydrukuje wiadomość “Woof! Woof!”. W klasie TestDog utwórz obiekt Dog, przypisz mu wartość null i spróbuj wywołać metodę bark. Przeanalizuj wynik.\nStwórz klasę Cat z polem name. Dodaj do klasy Cat metodę createCat, która zwraca nowy obiekt klasy Cat. Metoda powinna ustawiać pole name na podaną wartość, ale tylko jeśli wartość nie jest null. W przeciwnym razie powinna zwracać null. W klasie TestCat użyj metody createCat do stworzenia obiektu cat, a następnie spróbuj wydrukować wartość pola name. Co się stanie, jeśli przekażesz null jako argument do metody createCat? Przeanalizuj wynik.\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę Person z polem name. Dodaj do klasy metodę introduceYourself, która wyświetli wiadomość “Hi, I’m” i imię osoby. W klasie TestPerson, utwórz obiekt Person i wywołaj na nim metodę introduceYourself. Czy musisz użyć słowo kluczowe this w implementacji metody?\nDodaj do klasy Person metodę sayHello, która jako argument przyjmuje inny obiekt klasy Person i wyświetla wiadomość “Hello,” i imię drugiej osoby. Przeanalizuj działanie.\nDodaj do klasy Person metodę changeName, która jako argument przyjmuje łańcuch znaków i przypisuje go do pola name. Utwórz obiekt Person i użyj metody changeName do zmiany jego imienia. Następnie wywołaj metodę introduceYourself. Czy imię zostało zmienione? Czy musisz użyć słowo kluczowe this w implementacji metody?\nDodaj do klasy Person metodę swapNames, która jako argument przyjmuje inny obiekt klasy Person i zamienia imionami obie osoby. Utwórz dwa obiekty Person i użyj metody swapNames do zamiany ich imion. Następnie wywołaj metodę introduceYourself na obu obiektach. Czy imiona zostały zamienione?\n\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę Counter z jednym polem number. Dodaj do klasy metodę increase, która przyjmuje parametr typu int i zwiększa wartość pola number o wartość tego parametru. W klasie TestCounter, utwórz zmienną typu int, przekaż ją do metody increase i sprawdź, czy wartość zmiennej zmieniła się po wywołaniu metody.\nDodaj do klasy Counter metodę add, która przyjmuje inny obiekt Counter i dodaje wartość jego pola number do pola number bieżącego obiektu. Utwórz dwa obiekty Counter w klasie TestCounter i użyj metody add. Sprawdź, czy obiekt przekazany jako argument metody add zmienił swoją wartość po wywołaniu metody.\nStwórz klasę Modifier, która posiada metodę changeValue, która jako argument przyjmuje typ int. Wewnątrz metody zmień wartość argumentu na inną. W klasie TestCounter utwórz zmienną int, a następnie przekaż ją do metody changeValue i sprawdź, czy wartość zmiennej się zmieniła.\nDodaj do klasy Modifier metodę changeObject, która jako argument przyjmuje obiekt Counter. Wewnątrz metody zmień wartość pola number obiektu Counter na inną. W klasie TestCounter utwórz obiekt Counter, a następnie przekaż go do metody changeObject i sprawdź, czy wartość pola number obiektu się zmieniła."
  },
  {
    "objectID": "modyfikatorydostepu.html",
    "href": "modyfikatorydostepu.html",
    "title": "10  Modyfikatory dostępu",
    "section": "",
    "text": "Utwórz klasę Person z publicznym polem name oraz prywatnym polem password. Zobacz jak różne modyfikatory dostępu wpływają na dostęp do tych pól z innej klasy.\nStwórz dwie klasy: Parent i Child. Klasa Parent powinna mieć jedno pole protected. Spróbuj uzyskać dostęp do tego pola z klasy Child.\nUtwórz klasę Car z prywatną metodą engineFailure(). Spróbuj wywołać tę metodę z zewnątrz klasy.\nStwórz dwie klasy w tym samym pakiecie: Employee i Company. Klasa Employee powinna mieć pole bez modyfikatora dostępu. Spróbuj uzyskać dostęp do tego pola z klasy Company.\nUtwórz klasę BankAccount z publicznym polem accountNumber i prywatnym polem balance. Zobacz, jak różne modyfikatory dostępu wpływają na dostęp do tych pól z innej klasy.\nStwórz klasę Player z trzema polami: name (publiczne), age (pomijając modyfikator dostępu) oraz nationality (prywatne). W klasie Main stwórz tablicę zawodników i spróbuj zmienić wartości wszystkich pól. Obserwuj rezultaty.\nStwórz klasę Coach, która jest zadeklarowana jako private. Spróbuj stworzyć obiekt Coach w klasie Main. Jaki jest rezultat?"
  },
  {
    "objectID": "konstruktor.html",
    "href": "konstruktor.html",
    "title": "11  Konstruktor",
    "section": "",
    "text": "Napisz klasę Book, która będzie zawierać trzy pola: title, author, publicationYear. Następnie zaimplementuj dwa konstruktory - jeden domyślny, który nie przyjmuje żadnych argumentów, i drugi, który przyjmuje trzy argumenty odpowiadające polom klasy. W przypadku drugiego konstruktora, nazwy parametrów muszą być takie same jak nazwy pól. Sprawdź czy jesteś w stanie prawidłowo przypisać wartości do pól klasy używając słowa kluczowego this.\nZaprojektuj klasę Person, która będzie zawierać dwa pola: firstName, lastName. Zaimplementuj konstruktor, który przyjmuje dwa argumenty odpowiadające polom klasy. Nazwy parametrów muszą być takie same jak nazwy pól. Spróbuj przypisać wartości do pól klasy bez używania słowa kluczowego this. Czy jest to możliwe? Jeżeli nie, to dlaczego?\nStwórz klasę Car, która będzie zawierać trzy pola: brand, model, productionYear. Zaimplementuj trzy konstruktory - pierwszy domyślny, drugi przyjmujący dwa argumenty (brand i model), trzeci przyjmujący trzy argumenty (brand, model, productionYear). W przypadku drugiego i trzeciego konstruktora, nazwy parametrów muszą być takie same jak nazwy pól. Wykorzystaj słowo kluczowe this do rozróżnienia pól klasy od parametrów.\nNapisz klasę Person, która będzie miała pola: firstName, lastName i age. Zdefiniuj w niej dwa konstruktory, jeden przyjmujący wszystkie trzy parametry, a drugi tylko imię i nazwisko. Drugi konstruktor powinien wywołać pierwszy, przekazując mu domyślną wartość wieku jako 0.\nZaprojektuj klasę Square, która posiada pole side oraz konstruktor, który umożliwia ustawienie wartości tego pola. Następnie napisz drugi konstruktor, który nie przyjmuje żadnych argumentów, a jedynie wywołuje pierwszy konstruktor z wartością domyślną 1.\nZdefiniuj klasę Car, która ma pola: brand, model i productionYear. Klasa powinna zawierać dwa konstruktory: pierwszy przyjmujący wszystkie trzy parametry, a drugi tylko markę i model. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość productionYear jako aktualny rok.\nStwórz klasę Dog, która posiada pola: name, breed i age. Klasa powinna mieć dwa konstruktory: jeden, który przyjmuje wszystkie trzy parametry, a drugi, który przyjmuje tylko imię i rasę. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość wieku jako 1.\nNapisz klasę Student, która ma pola: firstName, lastName i fieldOfStudy. Zdefiniuj w niej dwa konstruktory, jeden przyjmujący wszystkie trzy parametry, a drugi tylko firstName i lastName. Drugi konstruktor powinien wywoływać pierwszy, przekazując mu domyślną wartość fieldOfStudy jako unknown.\nZdefiniuj klasę Employee, która posiada pola: firstName, lastName i salary. Napisz konstruktor, który przyjmuje dwa argumenty (firstName i lastName), oraz blok inicjujący, który ustawia wartość salary na 3000. Sprawdź, co stanie się, gdy w konstruktorze spróbujesz nadpisać wartość salary.\nZaprojektuj klasę Car, która posiada pola: brand, model i price. Napisz konstruktor, który przyjmuje dwa argumenty (brand i model), a w bloku inicjującym ustaw domyślną wartośćprice na 50000. Zobacz, co stanie się, gdy w konstruktorze spróbujesz zmienić wartość price.\nZdefiniuj klasę Phone, która ma pola: manufacturer, model i operatingSystem. W bloku inicjującym ustaw wartość operatingSystem na Android. Następnie napisz konstruktor, który przyjmuje dwa argumenty (manufacturer i model) i próbuje nadpisać wartość operatingSystem na iOS. Sprawdź, która wartość zostanie ostatecznie przypisana do pola operatingSystem.\nStwórz klasę Car zawierającą prywatne pola: brand, model, productionYear, mileage oraz color. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) dla wszystkich pól. Następnie dodaj metodę displayInformation(), która wyświetla wszystkie informacje o samochodzie.\nStwórz klasę Person z prywatnymi polami: firstName, lastName, age, address. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę introduceYourself(), która zwraca łańcuch znaków z informacjami o osobie.\nStwórz klasę Book z prywatnymi polami: title, author, publicationYear, publisher oraz numberOfPages. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę showInformation(), która wyświetla informacje o książce.\nStwórz klasę Point2D z prywatnymi polami x i y, reprezentującymi współrzędne punktu na płaszczyźnie. Dodaj konstruktor, który przyjmuje współrzędne jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę distance(Point2D anotherPoint), która oblicza odległość między dwoma punktami na płaszczyźnie.\nStwórz klasę Rectangle z prywatnymi polami width i height. Dodaj konstruktor, który przyjmuje długości boków jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody area() i perimeter(), które obliczają pole powierzchni i obwód prostokąta.\nStwórz klasę Circle z prywatnym polem radius. Dodaj konstruktor, który przyjmuje promień jako argument. Dodaj metody dostępowe (gettery i settery) oraz metody area() i circumference(), które obliczają pole powierzchni i obwód koła.\nStwórz klasę Student z prywatnymi polami: firstName, lastName, indexNumber, yearOfStudy oraz gradeAverage. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę showInformation(), która wyświetla informacje o studencie.\nStwórz klasę Employee z prywatnymi polami: firstName, lastName, position, age oraz salary. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę showInformation(), która wyświetla informacje o pracowniku.\nStwórz klasę BankAccount z prywatnymi polami: accountNumber, owner, balance oraz accountType. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody deposit(double amount) i withdraw(double amount), które odpowiednio dodają lub odejmują kwotę od salda konta.\nStwórz klasę Television z prywatnymi polami: brand, screenDiagonal, resolution, isSmartTV oraz price. Dodaj konstruktor, który przyjmuje wszystkie pola jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę showInformation(), która wyświetla informacje o telewizorze.\nStwórz klasę Gradebook z prywatnymi polami: firstName, lastName oraz grades (jako ArrayList typu int). Dodaj konstruktor, który przyjmuje firstName i lastName jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody addGrade(int grade) i removeGrade(int index), które odpowiednio dodają lub usuwają ocenę z listy ocen. Dodaj również metodę averageGrade() do obliczania i zwracania średniej ocen.\nStwórz klasę TemperatureHistory z prywatnym polem temperatures (jako ArrayList typu double). Dodaj konstruktor domyślny. Dodaj metody dostępowe (gettery i settery) oraz metody addTemperature(double temperature) i removeTemperature(int index), które odpowiednio dodają lub usuwają temperaturę z listy temperatur. Dodaj również metodę averageTemperature() do obliczania i zwracania średniej temperatur.\nStwórz klasę Results (wyniki testu) z prywatnymi polami: firstName, lastName oraz results (jako tablica typu int). Dodaj konstruktor, który przyjmuje firstName, lastName oraz rozmiar tablicy jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę addResult(int index, int result), która dodaje wynik testu na podanym indeksie. Dodaj również metodę averageResult() do obliczania i zwracania średniego wyniku.\nStwórz klasę TaskManager z prywatnym polem taskPriorities (jako ArrayList typu int). Dodaj konstruktor domyślny. Dodaj metody dostępowe (gettery i settery) oraz metody addPriority(int priority) i removePriority(int index), które odpowiednio dodają lub usuwają priorytet z listy priorytetów. Dodaj również metodę highestPriority() do znajdowania i zwracania wartości najwyższego priorytetu.\nStwórz klasę Warehouse z prywatnym polem productQuantities (jako tablica typu int). Dodaj konstruktor, który przyjmuje rozmiar tablicy jako argument. Dodaj metody dostępowe (getters and setters) oraz metodę addProducts(int index, int quantity), która dodaje określoną ilość produktów na podanym indeksie. Dodaj również metodę totalProducts() do obliczania i zwracania sumy wszystkich produktów w magazynie.\nZdefiniuj klasę Person, która posiada pola: firstName, lastName i age. Napisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól. Wiek osoby (age) nie powinien być ujemny, a firstName i lastName nie powinny być puste i nullem (w przypadku niepoprawnych wartości z osobna ustaw pusty napis lub zero).\nStwórz klasę Point, reprezentującą punkt w przestrzeni 3D, z polami: x, y, z. Napisz konstruktor, który przyjmuje te trzy wartości i sprawdza, czy są one w zakresie od -100 do 100. Jeśli wartości nie są w tym zakresie, powinny być ustawione na najbliższą granicę.\nZaprojektuj klasę Car, która posiada pola: brand, model i productionYear. Napisz konstruktor, który przyjmuje trzy argumenty. Zadaniem konstruktora jest sprawdzenie, czy productionYear nie jest większy niż aktualny rok oraz czy brand i model nie są puste i nullem (w przypadku niepoprawnych wartości z osobna ustaw pusty napis lub bieżący rok).\n\nWskazówka: wykorzystaj Calendar.getInstance().get(Calendar.YEAR) do pobrania aktualnego roku.\n\nZdefiniuj klasę BankAccount, która posiada pola: accountNumber i balance. Napisz konstruktor, który przyjmuje dwa argumenty. Przed przypisaniem wartości do pola accountNumber, sprawdź, czy jest ono 26-cyfrowe, a przed przypisaniem wartości do pola balance, sprawdź, czy balance nie jest ujemne (w przypadku niepoprawności wartości ustaw numer konta na taki, by składał się z samych jedynek a saldo na zero)."
  },
  {
    "objectID": "static.html",
    "href": "static.html",
    "title": "12  Pola i metody statyczne",
    "section": "",
    "text": "Stwórz klasę Person. Klasa powinna zawierać pole name oraz statyczne pole counter. Zadaniem jest zwiększanie wartości counter za każdym razem, gdy tworzona jest nowa instancja klasy Person. Dodaj metodę, która zwróci wartość counter. Stwórz przypadek testowy.\nStwórz klasę Mathematics, która posiada pole statyczne PI, które przechowuje przybliżoną wartość liczby \\(\\pi\\). Upewnij się, że wartość tego pola jest niemodyfikowalna. Stwórz przypadek testowy.\nStwórz klasę Singleton, która używa pola statycznego do przechowywania jednej i tylko jednej instancji tej klasy. Klasa powinna zawierać prywatny konstruktor oraz publiczną statyczną metodę getInstance(), która zwraca jedyną instancję klasy Singleton. Stwórz przypadek testowy.\nStwórz klasę Configuration, która zawiera pole statyczne applicationVersion z domyślną wartością “1.0”. Dodaj metody pozwalające na odczyt i zmianę tej wartości. Stwórz przypadek testowy.\nStwórz klasę Calculator, która posiada podstawowe metody matematyczne: dodawanie, odejmowanie, mnożenie i dzielenie. Zaimplementuj te metody jako metody statyczne. Utwórz drugą klasę, w której przetestujesz te metody bez tworzenia instancji klasy Calculator.\nStwórz klasę ShapeFactory, która posiada metody statyczne do tworzenia różnych figur geometrycznych, takich jak koła, kwadraty czy trójkąty. Następnie stwórz klasę testową, w której wykorzystasz te metody do stworzenia różnych figur, bez potrzeby tworzenia instancji klasy ShapeFactory.\nStwórz klasę Settings, która posiada różne parametry konfiguracyjne aplikacji (np. wersja, język). Dodaj metody niestatyczne do zmiany tych parametrów oraz statyczną metodę defaultSettings(), która zwróci domyślną konfigurację aplikacji. W klasie testowej zobacz, jak działają obie grupy metod i jakie są między nimi różnice.\nUtwórz klasę Configuration, która posiada pole statyczne applicationVersion oraz pole statyczne applicationName. Jedno z tych pól oznacz jako final. Zastanów się, co by się stało, gdybyś chciał zaktualizować wartość jednego z tych pól w trakcie działania aplikacji.\nStwórz klasę Product, która zawiera pole statyczne numberOfProducts oraz pole statyczne MAX_PRODUCTS. Pole numberOfProducts będzie służyć do zliczania ilości utworzonych produktów, a MAX_PRODUCTS do ograniczenia ich liczby. Oznacz tylko jedno z tych pól słowem kluczowym final i zastanów się nad konsekwencjami tego wyboru."
  },
  {
    "objectID": "rekord.html",
    "href": "rekord.html",
    "title": "13  Rekordy",
    "section": "",
    "text": "Stwórz rekord BookDTO, który reprezentuje książkę w sklepie internetowym. Powinien zawierać takie informacje jak title, author, price i yearOfPublication. Następnie stwórz kilka instancji tego rekordu, reprezentujących różne książki.\nUtwórz rekord Address, który zawiera street, houseNumber, postalCode i city. Następnie, stwórz rekord Person, który oprócz podstawowych informacji o osobie (np. firstName, lastName) zawiera również pole typu Address. Stwórz przypadek testowy.\nStwórz klasę PointC reprezentującą punkt na płaszczyźnie 2D z polami x i y. Następnie, stwórz rekord PointR z tymi samymi polami. Dodaj metody umożliwiające konwersję z instancji klasy na rekord i odwrotnie. Stwórz przypadek testowy.\nStwórz rekord Book, który reprezentuje title, author i yearOfPublication. Dodaj metodę describe(), która zwraca sformatowaną postać informacji o książce w stylu “Autor - Tytuł (Rok wydania)”. Stwórz przypadek testowy.\nStwórz rekord Point2D, reprezentujący punkt na płaszczyźnie 2D z koordynatami x i y. Wprowadź metodę distanceTo(Point2D otherPoint), która oblicza i zwraca odległość euklidesową między aktualnym punktem a podanym jako argument. Stwórz przypadek testowy.\nStwórz rekord Car, który zawiera brand, model i fuelConsumptionPer100km. Dodaj metodę fuelCost(double fuelPrice, double distance), która oblicza i zwraca koszt podróży na podstawie podanej ceny paliwa oraz dystansu. Stwórz przypadek testowy.\nStwórz rekord Student, który reprezentuje imię, nazwisko i listę ocen ucznia. Wprowadź metodę averageGrades(), która oblicza średnią ocen ucznia. Stwórz przypadek testowy.\nStwórz rekord Order, który zawiera listę produktów oraz ich cen. Każdy produkt reprezentowany jest przez rekord Product z nazwą i ceną. W rekordzie Order dodaj metodę totalValue(), która oblicza łączną wartość zamówienia na podstawie cen produktów. Stwórz przypadek testowy.\nStwórz rekord Person, który reprezentuje imię i wiek osoby. Dodaj konstruktor, który weryfikuje, czy podany wiek nie jest ujemny. W przypadku podania wartości ujemnej, ustaw wiek na 0. Stwórz przypadek testowy.\nStwórz rekord BankAccount, który zawiera numer konta oraz saldo. Dodaj konstruktor, który pozwala na tworzenie konta tylko z numerem, przy czym domyślne saldo wynosi 0. Stwórz przypadek testowy.\nStwórz rekord MusicTrack, który opisuje tytuł, artystę i czas trwania utworu w sekundach. Dodaj konstruktor, który przyjmuje tylko tytuł i artystę, przyjmując domyślną długość utworu jako 180 sekund. Stwórz przypadek testowy."
  },
  {
    "objectID": "tostringeqaulshashcode.html",
    "href": "tostringeqaulshashcode.html",
    "title": "14  Metody toString, equals i hashCode.",
    "section": "",
    "text": "Wykonaj poniższe czynności:\n\n\nZdefiniuj klasę Person, która posiada następujące pola: firstName, lastName i age.\nNapisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól.\n\nWiek osoby (age) nie powinien być ujemny. W przypadku podania wartości ujemnej dla wieku, ustaw wiek osoby na zero.\nPola firstName i lastName nie powinny być puste ani równać się null. W przypadku podania pustego napisu lub null dla tych pól, ustaw odpowiednio pusty napis.\n\nDodaj metodę toString(), która zwraca informacje o osobie w formacie: \"Person: [firstName] [lastName], Age: [age].\". Zwróć uwagę na wielkość liter i znaki interpunkcyjne.\nDodaj metodę equals(), która porównuje dwie osoby na podstawie ich pól firstName, lastName i age. Dwie osoby są uważane za identyczne, jeśli wszystkie trzy pola są takie same.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nZdefiniuj klasę Vehicle, która posiada następujące pola: brand, model i yearOfProduction.\nNapisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól.\n\nRok produkcji (yearOfProduction) nie powinien być większy od aktualnego roku. W przypadku podania wartości większej, ustaw rok produkcji na aktualny rok.\nPola brand i model nie powinny być puste ani równać się null. W przypadku podania pustego napisu lub null dla tych pól, ustaw odpowiednio pusty napis.\n\nDodaj metodę toString(), która zwraca informacje o pojeździe w formacie: \"Vehicle: [brand] [model], Year: [yearOfProduction].\".\nDodaj metodę equals(), która porównuje dwa pojazdy na podstawie ich pól brand, model i yearOfProduction.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nZdefiniuj klasę Book, która posiada następujące pola: title, author i numberOfPages.\nNapisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól.\n\nLiczba stron (numberOfPages) nie powinna być ujemna. W przypadku podania wartości ujemnej, ustaw liczbę stron na jedną.\nPola title i author nie powinny być puste ani równać się null. W przypadku podania pustego napisu lub null, ustaw odpowiednio pusty napis.\n\nDodaj metodę toString(), która zwraca informacje o książce w formacie: \"Book: [title] by [author], Pages: [numberOfPages].\".\nDodaj metodę equals(), która porównuje dwie książki na podstawie ich pól title, author i numberOfPages.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nZdefiniuj klasę Product, która posiada następujące pola: productName, category i price.\nNapisz konstruktor, który przyjmuje trzy argumenty i waliduje je przed przypisaniem do odpowiednich pól.\n\nCena (price) nie powinna być ujemna. W przypadku podania wartości ujemnej, ustaw cenę produktu na zero.\nPola productName i category nie powinny być puste ani równać się null. W przypadku podania pustego napisu lub null, ustaw odpowiednio pusty napis.\n\nDodaj metodę toString(), która zwraca informacje o produkcie w formacie: \"Product: [productName], Category: [category], Price: [price].\".\nDodaj metodę equals(), która porównuje dwa produkty na podstawie ich pól productName, category i price.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę Results (wyniki testu) z prywatnymi polami: firstName, lastName oraz results (jako tablica typu int). Dodaj konstruktor, który przyjmuje firstName, lastName oraz rozmiar tablicy jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metodę addResult(int index, int result), która dodaje wynik testu na podanym indeksie. Dodaj również metodę averageResult() do obliczania i zwracania średniego wyniku.\n\nDodaj metodę toString(), która zwraca informacje o uczniu, jego wynikach oraz zawartość tablicy results w formacie: \"Results for [firstName] [lastName]: Average Score = [averageResult], Results: [result1, result2, ...]. \". Ponadto dodaj metodę equals(), która porównuje dwa obiekty klasy Results na podstawie ich pól firstName, lastName oraz zawartości tablicy results. Dwa obiekty są uważane za identyczne, jeśli wszystkie pola i wyniki testów w tablicach są takie same. Dodaj także metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę CDAlbum z prywatnymi polami: artistName, albumTitle oraz tracks (jako tablica typu int reprezentująca długość każdego utworu w minutach).\nDodaj konstruktor, który przyjmuje artistName, albumTitle oraz ilość utworów jako argumenty.\nDodaj metody dostępowe (gettery i settery) oraz metodę addTrack(int index, int length), która dodaje długość utworu na podanym indeksie.\nDodaj również metodę totalLength() do obliczania i zwracania łącznej długości wszystkich utworów.\nDodaj metodę toString(), która zwraca informacje o artyście, albumie oraz czasie trwania wszystkich utworów w formacie: \"CDAlbum by [artistName]: [albumTitle], Total Length = [totalLength] minutes, Tracks Length: [length1, length2, ...]. \".\nDodaj metodę equals(), która porównuje dwa obiekty klasy CDAlbum na podstawie ich pól artistName, albumTitle oraz zawartości tablicy tracks. Dwa albumy są uważane za identyczne, jeśli wszystkie informacje są takie same.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę MovieRating z prywatnymi polami: movieTitle, directorName oraz ratings (jako tablica typu double reprezentująca oceny filmu w skali od 1 do 10).\nDodaj konstruktor, który przyjmuje movieTitle, directorName oraz ilość ocen jako argumenty.\nDodaj metody dostępowe (gettery i settery) oraz metodę addRating(int index, double rating), która dodaje ocenę filmu na podanym indeksie.\nDodaj również metodę averageRating() do obliczania i zwracania średniej oceny filmu.\nDodaj metodę toString(), która zwraca informacje o filmie, reżyserze, średniej ocenie oraz wszystkich ocenach w formacie: \"MovieRating for [movieTitle] by [directorName]: Average Rating = [averageRating], Ratings: [rating1, rating2, ...]. \".\nDodaj metodę equals(), która porównuje dwa obiekty klasy MovieRating na podstawie ich pól movieTitle, directorName oraz zawartości tablicy ratings. Dwa filmy są uważane za identyczne, jeśli wszystkie informacje są takie same.\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę Gradebook z prywatnymi polami: firstName, lastName oraz grades (jako ArrayList typu int). Dodaj konstruktor, który przyjmuje firstName i lastName jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody addGrade(int grade) i removeGrade(int index), które odpowiednio dodają lub usuwają ocenę z listy ocen. Dodaj również metodę averageGrade() do obliczania i zwracania średniej ocen.\nDodaj metodę toString(), która zwraca informacje o uczniu, średniej jego ocen oraz wszystkich ocenach w formacie: \"Gradebook for [firstName] [lastName]: Average Grade = [averageGrade], Grades: [grade1, grade2, ...].\". Zwróć uwagę na wielkość liter i znaki interpunkcyjne.\nDodaj metodę equals(), która porównuje dwa obiekty klasy Gradebook na podstawie ich pól firstName, lastName oraz zawartości listy grades. Dwa dzienniczki są uważane za identyczne, jeśli mają takie same imię, nazwisko i identyczny zestaw ocen (z uwzględnieniem kolejności).\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę Wallet z prywatnymi polami: ownerName, ownerSurname oraz coins (jako ArrayList typu double). Dodaj konstruktor, który przyjmuje ownerName i ownerSurname jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody addCoin(double coin) i removeCoin(int index), które odpowiednio dodają lub usuwają monetę z listy monet.\nDodaj również metodę totalAmount() do obliczania i zwracania łącznej kwoty w portfelu.\nDodaj metodę toString(), która zwraca informacje o właścicielu portfela, łącznej kwocie oraz wszystkich monetach w formacie: \"Wallet of [ownerName] [ownerSurname]: Total Amount = [totalAmount], Coins: [coin1, coin2, ...].\". Zwróć uwagę na wielkość liter i znaki interpunkcyjne.\nDodaj metodę equals(), która porównuje dwa obiekty klasy Wallet na podstawie ich pól ownerName, ownerSurname oraz zawartości listy coins. Dwa portfele są uważane za identyczne, jeśli mają tego samego właściciela i identyczny zestaw monet (bez uwzględnienia kolejności).\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę LibraryCard z prywatnymi polami: holderFirstName, holderLastName oraz booksBorrowed (jako ArrayList typu String). Dodaj konstruktor, który przyjmuje holderFirstName i holderLastName jako argumenty. Dodaj metody dostępowe (gettery i settery) oraz metody borrowBook(String bookTitle) i returnBook(String bookTitle), które odpowiednio dodają lub usuwają tytuł książki z listy wypożyczonych książek.\nDodaj również metodę numberOfBooksBorrowed() do obliczania i zwracania liczby wypożyczonych książek.\nDodaj metodę toString(), która zwraca informacje o posiadaczu karty, liczbie wypożyczonych książek oraz wszystkich tytułach wypożyczonych książek w formacie: \"Library card of [holderFirstName] [holderLastName]: Number of books borrowed = [numberOfBooksBorrowed], Books: [book1, book2, ...].\". Zwróć uwagę na wielkość liter i znaki interpunkcyjne.\nDodaj metodę equals(), która porównuje dwa obiekty klasy LibraryCard na podstawie ich pól holderFirstName, holderLastName oraz zawartości listy booksBorrowed. Dwóch posiadaczy kart bibliotecznych uważa się za identycznych, jeśli mają takie same imię, nazwisko i identyczny zestaw wypożyczonych książek (z zachowaniem kolejności).\nDodaj metodę hashCode(), która generuje kod hash dla odpowiedniego obiektu. Metoda ta powinna być zgodna z metodą equals()"
  },
  {
    "objectID": "dziedziczenie.html",
    "href": "dziedziczenie.html",
    "title": "15  Dziedziczenie",
    "section": "",
    "text": "Wykonaj kolejno poniższe czynności:\n\nStwórz klasę bazową Person z prywatnym polem firstName oraz chronionym polem lastName. Następnie stwórz klasę Employee, która dziedziczy po klasie Person. W klasie Employee próbuj odnieść się do obu pól i zauważ, które z nich są dostępne.\nNa bazie klasy Person z poprzedniego podpunktu, stwórz metody dostępowe (gettery) dla obu pól. W klasie Employee stwórz metodę displayData, która korzysta z tych metod dostępowych, aby wypisać informacje o pracowniku. Zastanów się, dlaczego metody dostępowe są używane do dostępu do prywatnych pól.\n\nStwórz klasę bazową Book z prywatnym polem title oraz chronionym polem author. Stwórz klasę potomną Ebook, która dziedziczy po klasie Book. W klasie Ebook spróbuj zmienić modyfikator dostępu dla obu pól z klasy bazowej. Zastanów się, dlaczego jedno z pól pozwala na to, a drugie nie.\nStwórz klasę Tool z chronionym konstruktorem, który przyjmuje nazwę narzędzia. Następnie stwórz klasę potomną Hammer, która dziedziczy po klasie Tool. W klasie Hammer stwórz konstruktor, który korzysta z konstruktora klasy bazowej. Zastanów się, dlaczego używając modyfikatora private dla konstruktora klasy bazowej, taki scenariusz nie byłby możliwy.\nStwórz dwa różne pakiety: animals i mammals. W pakiecie animals stwórz klasę bazową Animal z chronionym polem species i prywatnym polem age. W pakiecie mammals stwórz klasę Dog, która dziedziczy po klasie Animal. Spróbuj odnieść się w klasie Dog do obu pól z klasy bazowej i zauważ, które z nich są dostępne.\nWykonaj kolejno poniższe czynności:\n\nStwórz klasę bazową Vehicle z metodą drive, która wypisuje “The vehicle is moving.”. Następnie stwórz klasę potomną Car, która nadopisuje metodę drive tak, by wypisywała “The car is moving.”. Utwórz obiekt klasy Car i wywołaj jego metodę drive, aby zaobserwować wynik.\nNa bazie klasy Vehicle z poprzedniego podpunktu, w klasie Car, nadpisz metodę drive tak, by wywoływała oryginalną metodę z klasy bazowej i dodatkowo wypisywała informacje specyficzne dla klasy Car. Użyj słowa kluczowego super, aby wywołać metodę z klasy bazowej.\n\nStwórz klasę Calculator z metodą add, która przyjmuje dwa argumenty typu int i zwraca ich sumę. Następnie stwórz klasę potomną ExtendedCalculator, która nadpisuje metodę add w taki sposób, by przyjmowała trzy argumenty typu int i zwracała ich sumę. Zastanów się, czy to faktycznie nadpisywanie metody, czy może coś innego.\nStwórz klasę bazową Base z metodą statyczną info, która wypisuje “This is the base class.”. Następnie stwórz klasę potomną Child i próbuj przesłonić metodę statyczną info tak, by wypisywała “This is the child class.”. Zastanów się nad zachowaniem tak przesłoniętych metod i dlaczego takie przesłanianie jest inaczej traktowane.\nStwórz klasę bazową Computer z chronioną metodą start, która wypisuje “Computer started.”. Stwórz klasę potomną Laptop, która próbuje nadpisać metodę start, ale z modyfikatorem dostępu public. Spróbuj skompilować kod i zastanów się, dlaczego występują pewne ograniczenia w nadpisywaniu metod pod względem modyfikatorów dostępu.\nStwórz klasę bazową o nazwie Vehicle z polami: brand i model. Klasa ta powinna posiadać konstruktor przyjmujący oba te parametry. Następnie stwórz klasę potomną o nazwie Car, która dziedziczy po klasie Vehicle. Klasa Car powinna posiadać dodatkowe pole numberOfDoors. Stwórz konstruktor dla klasy Car, który przyjmuje wszystkie trzy parametry i korzysta z konstruktora klasy bazowej. Stwórz przypadek testowy.\nStwórz klasę bazową o nazwie Animal z polem name oraz konstruktor z domyślnym przypisaniem nazwy do “Unknown”. Następnie stwórz klasę Dog, która dziedziczy po klasie Animal. Nie twórz w niej dodatkowego konstruktora. Sprawdź, jakie zwierzę zostanie utworzone, gdy stworzysz nową instancję klasy Dog.\nStwórz klasę bazową o nazwie Building z polami: height i color. Klasa ta powinna posiadać dwa konstruktory: jeden przyjmujący oba parametry i drugi bezparametrowy, który przypisuje domyślne wartości. Stwórz klasę potomną House z dodatkowym polem numberOfRooms. Klasa House powinna posiadać konstruktor, który wykorzystuje przeciążony konstruktor klasy bazowej. Stwórz przypadek testowy.\nStwórz trzy klasy: Entity, Human i Programmer. Klasa Human powinna dziedziczyć po klasie Entity, a klasa Programmer po klasie Human. W każdej z klas dodaj konstruktor, który wypisuje informację o tworzeniu instancji danej klasy. Stwórz instancję klasy Programmer i zaobserwuj kolejność wywoływania konstruktorów.\nUtwórz klasę Vehicle z polami brand, model i yearOfProduction. Utwórz klasy Car i Motorcycle, które dziedziczą po klasie Vehicle. Klasa Car powinna mieć dodatkowe pole numberOfDoors, a klasa Motorcycle pole engineCapacity. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Employee z polami firstName, lastName i salary. Utwórz klasy Programmer i Tester, które dziedziczą po klasie Employee. Klasa Programmer powinna mieć dodatkowe pole programmingLanguage, a klasa Tester pole testingType. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Property z polami address, size i price. Utwórz klasy House i Apartment, które dziedziczą po klasie Property. Klasa House powinna mieć dodatkowe pole numberOfFloors, a klasa Apartment pole floorNumber. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę BoardGame z polami gameName, minPlayers, maxPlayers oraz rules (jako ArrayList typu String). Utwórz klasy EducationalGame i StrategicGame, które dziedziczą po klasie BoardGame. Klasa EducationalGame powinna mieć dodatkowe pole subject, a klasa StrategicGame pole duration. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Team z polami name, city oraz points (jako ArrayList typu Integer). Utwórz klasy SoccerTeam i VolleyballTeam, które dziedziczą po klasie Team. Klasa SoccerTeam powinna mieć dodatkowe pole rankingPosition, a klasa VolleyballTeam pole numberOfVictories. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Computer z polami manufacturer, model oraz partsPrices (jako ArrayList typu Double). Utwórz klasy Laptop i Desktop, które dziedziczą po klasie Computer. Klasa Laptop powinna mieć dodatkowe pole weight, a klasa Desktop pole caseType. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę MusicAlbum z polami title, artist oraz ratings (jako ArrayList typu Integer). Utwórz klasy RockAlbum i JazzAlbum, które dziedziczą po klasie MusicAlbum. Klasa RockAlbum powinna mieć dodatkowe pole rockGenre, a klasa JazzAlbum pole jazzGenre. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Book z polami author, title i yearOfPublication. Następnie utwórz dwie klasy pochodne: Ebook, która dodaje pole fileSize i PaperbackBook, która dodaje pole numberOfPages. Każda z klas powinna zawierać konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode(). W metodzie equals() klasy Book porównaj tylko author, w klasie Ebook po author i fileSize, a w klasie PaperbackBook porównaj author i numberOfPages. Napisz program testujący te klasy, demonstrujący działanie polimorfizmu i porównanie obiektów.\nZaprojektuj klasę Employee z polami name, department i salary. Utwórz dwie klasy pochodne: Manager z dodatkowym polem bonus i Intern z polem internshipLength. Każda klasa powinna mieć konstruktory, gettery i settery, toString(), equals() oraz hashCode(). W metodzie equals() klasy Employee porównaj tylko name, w klasie Manager po name i bonus, a w klasie Intern porównaj name i internshipLength. Napisz program testujący te klasy, demonstrujący działanie polimorfizmu i porównanie obiektów."
  },
  {
    "objectID": "pakiety.html",
    "href": "pakiety.html",
    "title": "16  Pakiety",
    "section": "",
    "text": "Stwórz pakiet o nazwie cars. Wewnątrz tego pakietu utwórz klasę Car zawierającą trzy prywatne pola: brand, model i yearOfProduction. Dodaj do klasy odpowiednie metody dostępowe (gettery i settery) oraz konstruktor przyjmujący wszystkie trzy pola. W klasie testującej, poza tym pakietem, stwórz obiekt klasy Car, nadaj mu wartości i wydrukuj je na ekran.\nStwórz pakiet o nazwie animals. Wewnątrz tego pakietu utwórz dwie klasy: Dog i Cat. Oba powinny zawierać pola name i age. Każda z klas powinna posiadać metodę makeSound(). Dla klasy Dog metoda ta powinna drukować “Woof, woof!”, a dla klasy Cat - “Meow!”. W klasie testującej, poza tym pakietem, stwórz obiekty obu klas, nadaj im wartości i wywołaj ich metody makeSound().\nStwórz dwa pakiety: employees i tools. W pakiecie employees utwórz klasę Employee z polami firstName, lastName oraz salary. Pole salary powinno być chronione (protected). W pakiecie tools stwórz klasę SalaryCalculator, która posiada metodę raiseSalary(Employee employee, double percent), która zwiększa pensję pracownika o podany procent. Spróbuj wywołać tę metodę w klasie testującej, poza oboma pakietami, i zastanów się nad problemami dostępu do chronionych pól w różnych pakietach.\nStwórz pakiet o nazwie electronics. Wewnątrz tego pakietu stwórz dwa podpakiety: televisions i phones. W podpakiecie televisions utwórz klasę Television z polami brand i screenDiagonal. W podpakiecie phones utwórz klasę Phone z polami brand i operatingSystem. Dla obu klas dodaj odpowiednie gettery, settery oraz konstruktory. W klasie testującej, poza pakietem electronics, stwórz obiekty obu klas, nadaj im wartości i wyświetl je.\nStwórz dwa pakiety: books i library. W pakiecie books stwórz klasę Book z polami title, author i publicationYear. W pakiecie library stwórz klasę Shelf zawierającą listę książek oraz metody umożliwiające umożliwiające dodawanie i usuwanie książek. Aby korzystać z klasy Book w pakiecie library, musisz zaimportować odpowiedni pakiet. W klasie testującej, stwórz kilka książek, dodaj je do półki i wydrukuj zawartość półki.\nStwórz pakiet bank. Wewnątrz tego pakietu stwórz dwie klasy: Account i Bank. Klasa Account powinna posiadać prywatne pola accountNumber, balance oraz metody deposit(double amount) i withdraw(double amount). Klasa Bank powinna zawierać listę kont oraz metody do tworzenia new kont i realizacji przelewów między nimi. Spróbuj utworzyć konto bezpośrednio w klasie testującej poza pakietem bank i zastanów się, jak modyfikatory dostępu wpłynęły na dostęp do klas i metod w pakiecie.\nStwórz pakiet o nazwie animals. Wewnątrz tego pakietu utwórz klasę bazową Animal z polami: name i age oraz metodą makeSound(). Następnie, w tym samym pakiecie, stwórz dwie klasy pochodne: Dog i Cat, które dziedziczą po klasie Animal. Klasy pochodne powinny nadpisywać metodę makeSound(). W klasie testującej, poza pakietem animals, stwórz obiekty obu klas pochodnych, nadaj im wartości i wywołaj metodę makeSound() dla każdego z nich.\nStwórz pakiet o nazwie computers. W tym pakiecie utwórz klasę bazową Computer z polami: brand i processor. Następnie stwórz dwie klasy pochodne: Laptop i Desktop. Klasa Laptop powinna dodatkowo posiadać pole weight, a klasa Desktop pole caseType. Wszystkie klasy powinny posiadać odpowiednie gettery, settery oraz konstruktory. W klasie testującej, poza pakietem computers, stwórz obiekty obu klas pochodnych, nadaj im wartości i wydrukuj je.\nStwórz pakiet o nazwie company. Wewnątrz tego pakietu utwórz klasę bazową Employee z polami: firstName, lastName i salary. Następnie stwórz dwie klasy pochodne: Manager i Developer. Klasa Manager powinna dodatkowo posiadać pole bonus, a klasa Developer pole programmingLanguage. Dodaj odpowiednie metody pozwalające na obliczanie rocznego zarobku (pensja + ewentualne premie). W klasie testującej, poza pakietem company, stwórz obiekty obu klas pochodnych, nadaj im wartości i oblicz ich roczne zarobki."
  },
  {
    "objectID": "zlozonepolawklasie.html",
    "href": "zlozonepolawklasie.html",
    "title": "17  Złożone pola w klasie",
    "section": "",
    "text": "Utwórz klasę MusicAlbum z polami title, artist oraz ratings (jako tablica z elementami typu double). Dodaj metodę pozwalającą na dodawanie i usuwanie ocen. Utwórz klasę RockAlbum, która dziedziczy po klasie MusicAlbum. Klasa RockAlbum powinna mieć dodatkowe pole rockGenre. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Book z polami title, author oraz reviews (jako tablica z elementami typu double). Dodaj metody pozwalające na dodawanie i usuwanie recenzji. Utwórz klasę FantasyBook, która dziedziczy po klasie Book. Klasa FantasyBook powinna mieć dodatkowe pole fantasySubgenre. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę ComputerGame z polami title, producer oraz ratings (jako tablica z elementami typu double). Dodaj metody pozwalające na dodawanie i usuwanie ocen. Utwórz klasę RPGGame, która dziedziczy po klasie ComputerGame. Klasa RPGGame powinna mieć dodatkowe pole gameWorld. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę University z polami name, location oraz studyPrograms (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie kierunków studiów. Utwórz klasę TechnicalUniversity, która dziedziczy po klasie University. Klasa TechnicalUniversity powinna mieć dodatkowe pole numberOfLaboratories. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę ArtGallery z polami name, city oraz paintings (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie obrazów. Utwórz klasę ContemporaryGallery, która dziedziczy po klasie ArtGallery. Klasa ContemporaryGallery powinna mieć dodatkowe pole numberOfInstallations. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nUtwórz klasę Car z polami brand, model oraz engineVariants (jako tablica z elementami typu String). Dodaj metody pozwalające na dodawanie i usuwanie wariantów silników. Utwórz klasę ElectricCar, która dziedziczy po klasie Car. Klasa ElectricCar powinna mieć dodatkowe pole range. Dodaj konstruktory, metody gettery i settery, metodę toString(), equals() oraz hashCode() dla każdej z klas. Napisz program testujący zdefiniowane klasy i metody.\nWykonaj poniższe czynności:\n\n\nStwórz klasę Engine (Silnik) z polami: power (moc), type (typ silnika), serialNumber (numer seryjny). Dodaj konstruktor parametryczny, gettery, settery, oraz metody toString, equals i hashCode.\nStwórz klasę Car (Samochód). Klasa Car powinna mieć pola: make (marka), model (model), engine typu Engine (silnik). Dodaj konstruktor parametryczny, który przyjmuje obiekt Engine jako parametr, gettery, settery, oraz metody toString, equals i hashCode.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę Processor (Procesor) z polami: frequency (częstotliwość), cores (liczba rdzeni), manufacturer (producent). Dodaj konstruktor parametryczny, gettery, settery, oraz metody toString, equals i hashCode.\nStwórz klasę Computer (Komputer). Klasa Computer powinna mieć pola: brand (marka), model (model), processor typu Processor (procesor). Dodaj konstruktor parametryczny, który przyjmuje obiekt Processor jako parametr, gettery, settery, oraz metody toString, equals i hashCode.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę Address (Adres) z polami: street (ulica), city (miasto), zipCode (kod pocztowy), country (kraj). Dodaj konstruktor parametryczny, gettery, settery, oraz metody toString, equals i hashCode.\nStwórz klasę UserAccount (Konto Użytkownika). Klasa UserAccount powinna mieć pola: username (nazwa użytkownika), email (email), address typu Address (adres). Dodaj konstruktor parametryczny, który przyjmuje obiekt Address jako parametr, gettery, settery, oraz metody toString, equals i hashCode."
  },
  {
    "objectID": "klasyabstrakcyjne.html",
    "href": "klasyabstrakcyjne.html",
    "title": "18  Klasy abstrakcyjne",
    "section": "",
    "text": "Zdefiniuj abstrakcyjną klasę WorkTool z polami name typu String oraz productionYear typu int. Dodaj metodę abstrakcyjną use(), która będzie symulować użycie narzędzia. Następnie zdefiniuj klasy Hammer, Screwdriver i Saw, które dziedziczą po klasie WorkTool i implementują metodę use(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę.\nZdefiniuj abstrakcyjną klasę ComputerGraphic z polami width, height typu int oraz fileName typu String. Dodaj abstrakcyjne metody loadFile() i saveFile(). Następnie zdefiniuj klasy Bitmap i Vector, które dziedziczą po klasie ComputerGraphic i implementują metody loadFile() oraz saveFile(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę.\nZdefiniuj abstrakcyjną klasę ElectronicDevice z polami manufacturer typu String, model typu String oraz productionYear typu int. Dodaj abstrakcyjne metody turnOn() i turnOff(). Następnie zdefiniuj klasy Smartphone, Television i Laptop, które dziedziczą po klasie ElectronicDevice i implementują metody turnOn() oraz turnOff(). Stwórz listę tablicową odpowiednich 5 obiektów i wywołaj dla nich napisaną metodę."
  },
  {
    "objectID": "final.html",
    "href": "final.html",
    "title": "19  Pola, metody, klasy finalne",
    "section": "",
    "text": "Wykonaj kolejno czynności:\nA. Stwórz klasę Planet z jednym polem finalnym name. Spróbuj zmienić wartość pola name po jego inicjalizacji. Przeanalizuj wynik.\nB. Dodaj do klasy Planet metodę changeName, która próbuje zmienić nazwę planety. Jaki jest wynik próby zmiany finalnego pola za pomocą metody?\nStwórz klasę Car z dwoma polami: brand (normalne pole) i VIN (pole finalne - Numer Identyfikacyjny Pojazdu). Stwórz kilka obiektów Car i spróbuj zmienić pole VIN dla każdego z nich. Przeanalizuj wynik.\nStwórz klasę Athlete z jednym polem finalnym name oraz polem points. Stwórz tablicę zawodników i spróbuj zmienić pole name dla jednego z zawodników. Przeanalizuj wynik.\nStwórz klasę Person z jednym polem finalnym PESEL. Następnie stwórz klasę Student, która dziedziczy po klasie Person. Czy możesz zmienić pole PESEL w klasie Student? Co się stanie, jeśli spróbujesz to zrobić? Przeanalizuj wyniki.\nStwórz klasę bazową Electronics z metodą finalną turnOn, która wypisuje “Urządzenie włączone”. Następnie stwórz klasę potomną Television i spróbuj przesłonić metodę turnOn. Zaobserwuj, co się dzieje.\nStwórz klasę Computer z metodą finalną boot oraz zwykłą metodą launchApplication. W klasie potomnej Laptop, spróbuj przesłonić obie metody. Sprawdź, która z metod pozwoli się przesłonić, a której nie.\nUtwórz finalną klasę ImmutableData z pewnymi atrybutami i metodami. Następnie spróbuj stworzyć klasę potomną VariableData, która dziedziczy po klasie ImmutableData. Zastanów się, dlaczego nie można dziedziczyć po klasie oznaczonej jako final.\nStwórz klasę Game, która w swoim konstruktorze ma metodę finalną initialize (inicializującą pewne dane). Utwórz klasę potomną RPG, która próbuje dostosować konstruktor klasy bazowej. Upewnij się, że metoda initialize działa poprawnie, mimo że jest oznaczona jako final.\nUtwórz klasę MathConstant z finalnym polem PI, które jest inicjowane wartością 3.14159. W klasie potomnej PhysicalConstant, spróbuj stworzyć metodę, która próbuje zmienić wartość PI. Zastanów się, dlaczego wartość finalnego pola nie może zostać zmieniona po jego inicjalizacji.\nWykonaj poniższe czynności:\n\n\nStwórz klasę ImmutableDate z prywatnymi finalnymi polami: year (rok), month (miesiąc), day (dzień).\nDodaj konstruktor parametryczny do inicjalizacji wszystkich pól.\nDodaj publiczne metody getYear, getMonth, getDay do pobierania wartości pól, ale nie dodawaj żadnych metod umożliwiających ich modyfikację.\nZaimplementuj metody toString, equals i hashCode.\nSprawdź, czy taka klasa może być uznana jako niemodyfikowalna (inmutable).\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę ImmutablePoint z prywatnymi finalnymi polami: x, y, z (współrzędne punktu).\nDodaj konstruktor parametryczny do inicjalizacji wszystkich pól.\nDodaj publiczne metody getX, getY, getZ do pobierania wartości pól, ale nie dodawaj żadnych metod umożliwiających ich modyfikację.\nZaimplementuj metody toString, equals i hashCode.\nSprawdź, czy taka klasa może być uznana jako niemodyfikowalna (inmutable).\n\n\nWykonaj poniższe czynności:\n\n\nStwórz klasę ImmutableBook z prywatnymi finalnymi polami: title (tytuł), author (autor), isbn (numer ISBN).\nDodaj konstruktor parametryczny do inicjalizacji wszystkich pól.\nDodaj publiczne metody getTitle, getAuthor, getIsbn do pobierania wartości pól, ale nie dodawaj żadnych metod umożliwiających ich modyfikację.\nZaimplementuj metody toString, equals i hashCode.\nSprawdź, czy taka klasa może być uznana jako niemodyfikowalna (inmutable)."
  },
  {
    "objectID": "comparable.html",
    "href": "comparable.html",
    "title": "20  Interfejs Comparable",
    "section": "",
    "text": "Napisz klasę Student, która zawiera pola: name (typu String), averageGrade (typu double) i yearOfBirth (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Student były sortowane malejąco według średniej ocen. Stwórz listę tablicową 5 obiektów klasy Student i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Employee, która zawiera pola: name (typu String), salary (typu double) i employmentDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Employee były sortowane rosnąco według pensji. Stwórz listę tablicową 5 obiektów klasy Employee i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Client, która zawiera pola: name (typu String), clientNumber (typu int) i lastLogin (typu Date). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Client były sortowane malejąco według daty ostatniego logowania. Stwórz listę tablicową 5 obiektów klasy Client i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Product, która zawiera pola: name (typu String), price (typu double) i productionDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Product były sortowane rosnąco według daty produkcji. Stwórz listę tablicową 5 obiektów klasy Product i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Person, która zawiera pola: name (typu String), height (typu int) i dateOfBirth (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Person były sortowane malejąco według wzrostu. Stwórz listę tablicową 5 obiektów klasy Person i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Book, która zawiera pola: title (typu String), numberOfPages (typu int) i publicationDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Book były sortowane malejąco według liczby stron. Stwórz tablicę 4 obiektów klasy Book i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Car, która zawiera pola: brand (typu String), mileage (typu int) i yearOfProduction (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Car były sortowane rosnąco według przebiegu. Stwórz tablicę 4 obiektów klasy Car i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę FoodProduct, która zawiera pola: name (typu String), price (typu double) i expirationDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy FoodProduct były sortowane rosnąco według daty ważności. Stwórz tablicę 4 obiektów klasy FoodProduct i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Music, która zawiera pola: title (typu String), artist (typu String) i releaseYear (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Music były sortowane malejąco według roku wydania. Stwórz tablicę 4 obiektów klasy Music i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Item, która zawiera pola: name (typu String), weight (typu double) i price (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Item były sortowane rosnąco według wagi. Stwórz tablicę 4 obiektów klasy Item i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Student, która zawiera pola: name (typu String), averageGrade (typu double) i yearOfStudy (typu int). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Student były sortowane według jednego kryterium: malejąco według średniej ocen, a przy równości sortowane były rosnąco według roku studiów. Stwórz tablicę 4 obiektów klasy Student i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Order, która zawiera pola: productName (typu String), quantity (typu int) i unitPrice (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Order były sortowane według jednego kryterium: malejąco według ceny jednostkowej, a przy równości sortowane były rosnąco według ilości. Stwórz listę tablicową 4 obiektów klasy Order i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Client, która zawiera pola: name (typu String), balance (typu double) i lastPurchaseDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Client były sortowane według jednego kryterium: malejąco według salda, a przy równości sortowane były rosnąco według daty ostatnich zakupów. Stwórz listę tablicową 4 obiektów klasy Client i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Course, która zawiera pola: name (typu String), numberOfHours (typu int) i price (typu double). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Course były sortowane według jednego kryterium: rosnąco według liczby godzin, a przy równości sortowane były malejąco według ceny. Stwórz tablicę 4 obiektów klasy Course i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Product, która zawiera pola: name (typu String), price (typu double) i expirationDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Product były sortowane według jednego kryterium: malejąco według daty ważności, a przy równości sortowane były rosnąco według ceny. Stwórz listę obiektów klasy Product i posortuj ją według sprecyzowanego kryterium. Następnie wyświetl posortowaną listę na ekranie.\nNapisz klasę Car, która zawiera pola: brand (typu String), model (typu String) i registrationNumber (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Car były sortowane według jednego kryterium: rosnąco według długości numeru rejestracyjnego. Stwórz tablicę 4 obiektów klasy Car i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Employee, która zawiera pola: firstName (typu String), lastName (typu String) i position (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Employee były sortowane według jednego kryterium: rosnąco według długości nazwiska. Stwórz listę tablicową 4 obiektów klasy Employee i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Movie, która zawiera pola: title (typu String), director (typu String) i genre (typu String). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Movie były sortowane według jednego kryterium: rosnąco według długości tytułu. Stwórz listę tablicową 4 obiektów klasy Movie i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Book, która zawiera pola: title (typu String), author (typu String) i publishDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Book były sortowane według jednego niestandardowego kryterium: rosnąco według roku wydania. Stwórz tablicę 4 obiektów klasy Book i posortuj ją według sprecyzowanego kryterium.\nNapisz klasę Product, która zawiera pola: name (typu String), price (typu double) i productionDate (typu LocalDate). Zaimplementuj interfejs Comparable w taki sposób, aby obiekty klasy Product były sortowane według jednego niestandardowego kryterium: malejąco według roku produkcji. Stwórz listę tablicową 4 obiektów klasy Product i posortuj ją według sprecyzowanego kryterium.\nZdefiniuj klasę Client, która będzie implementować generyczny interfejs Comparable. W klasie tej zadeklaruj prywatne pola lastName typu String oraz balance typu double. Implementując metodę compareTo interfejsu Comparable, porównuj klientów na podstawie ich salda, a w przypadku takiego samego salda - na podstawie nazwiska. Następnie zdefiniuj klasę Company dziedziczącą po klasie Client. Klasa Company ma dodatkowo posiadać prywatne pole numberOfEmployees typu int. Implementując metodę compareTo interfejsu Comparable w klasie Company, skorzystaj z metody compareTo zdefiniowanej w klasie Client oraz, w razie potrzeby, uwzględnij pole numberOfEmployees. Napisz program TestClient, w którym utwórz listę tablicową 5 klientów i firm o nazwie clientList posługując się klasą ArrayList. W składzie listy powinny wystąpić przynajmniej dwóch klientów o takim samym saldzie i różnym nazwisku oraz dwie firmy o takiej samej liczbie pracowników i różnym saldzie. Wyświetl zawartość listy clientList, posortuj ją za pomocą instancyjnej metody sort z klasy ArrayList i ponownie wyświetl zawartość tej listy.\nZdefiniuj klasę Animal, która będzie implementować generyczny interfejs Comparable. W klasie tej zadeklaruj prywatne pola species typu String oraz age typu int. Implementując metodę compareTo interfejsu Comparable, porównuj zwierzęta na podstawie ich wieku, a w przypadku takiego samego wieku - na podstawie gatunku. Następnie zdefiniuj klasę Dog dziedziczącą po klasie Animal. Klasa Dog ma dodatkowo posiadać prywatne pole breed typu String. Implementując metodę compareTo interfejsu Comparable w klasie Dog, skorzystaj z metody compareTo zdefiniowanej w klasie Animal oraz, w razie potrzeby, uwzględnij pole breed. Napisz program TestAnimal, w którym utwórz listę tablicową 5 zwierząt i psów o nazwie animalList posługując się klasą ArrayList. W składzie listy powinny wystąpić przynajmniej po 3 obiekty różnych typów."
  },
  {
    "objectID": "comparator.html",
    "href": "comparator.html",
    "title": "21  Interfejs Comparator",
    "section": "",
    "text": "Napisz klasę Osoba z polami imie (String), wiek (int) i wzrost (double). Napisz klasę implementującą interfejs Comparator, która porównuje osoby na podstawie wieku. Stwórz tablicę 5 osób i posortuj ją według wieku.\nNapisz klasę Produkt z polami nazwa (String), cena (double) i dataWaznosci (LocalDate). Napisz klasę implementującą interfejs Comparator, która porównuje produkty na podstawie daty ważności. Stwórz listę 5 produktów i posortuj ją według daty ważności.\nNapisz klasę Samochod z polami marka (String), rokProdukcji (int) i cena (double). Napisz klasę implementującą interfejs Comparator, która porównuje samochody na podstawie roku produkcji. Stwórz tablicę 5 samochodów i posortuj ją według roku produkcji.\nNapisz klasę Pracownik z polami imie (String), pensja (double) i dataZatrudnienia (LocalDate). Napisz klasę implementującą interfejs Comparator, która porównuje pracowników na podstawie pensji. Stwórz tablicę 5 pracowników i posortuj ją według pensji.\nNapisz klasę Ksiazka z polami tytul (String), cena (double) i dataWydania (Date). Napisz klasę implementującą interfejs Comparator, która porównuje książki na podstawie daty wydania. Stwórz listę 5 książek i posortuj ją według daty wydania.\nNapisz klasę Product z polami id (typu int), name (typu String) oraz price (typu double). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu price (od najniższej do najwyższej ceny), a w przypadku równości po polu id. Stwórz listę 5 obiektów klasy Product i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Person z polami firstName (typu String), lastName (typu String) oraz birthDate (typu LocalDate). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu lastName (alfabetycznie od A do Z), a w przypadku równości po polu firstName. Stwórz tablicę 5 obiektów klasy Person i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Order z polami id (typu int), customerName (typu String) oraz orderDate (typu LocalDate). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu orderDate (od najwcześniejszej do najpóźniejszej daty), a w przypadku równości po polu id. Stwórz listę 5 obiektów klasy Order i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Song z polami title (typu String), artist (typu String) oraz duration (typu int). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu duration (od najkrótszej do najdłuższej piosenki), a w przypadku równości po polu title. Stwórz tablicę 5 obiektów klasy Song i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Student z polami id (typu int), name (typu String) oraz averageGrade (typu double). Zaimplementuj generyczny interfejs Comparator do porównywania obiektów po polu averageGrade (od najwyższej do najniższej średniej ocen), a w przypadku równości po polu name. Stwórz listę 5 obiektów klasy Student i posortuj ją zgodnie z opisanym kryterium.\nNapisz klasę Product z polami id (typu int), name (typu String) oraz price (typu double). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: PriceComparator do porównywania obiektów po polu price (od najniższej do najwyższej ceny) oraz NameComparator do porównywania obiektów po polu name (alfabetycznie od A do Z). Stwórz listę 5 obiektów klasy Product i posortuj ją zgodnie z oboma kryteriami (najpierw po cenie, a następnie po nazwie).\nNapisz klasę Person z polami firstName (typu String), lastName (typu String) oraz birthDate (typu LocalDate). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: LastNameComparator do porównywania obiektów po polu lastName (alfabetycznie od A do Z) oraz BirthDateComparator do porównywania obiektów po polu birthDate (od najstarszej do najmłodszej osoby). Stwórz tablicę 5 obiektów klasy Person i posortuj ją zgodnie z oboma kryteriami (najpierw po nazwisku, a następnie po dacie urodzenia).\nNapisz klasę Order z polami id (typu int), customerName (typu String) oraz orderDate (typu LocalDate). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: OrderDateComparator do porównywania obiektów po polu orderDate (od najwcześniejszej do najpóźniejszej daty) oraz CustomerNameComparator do porównywania obiektów po polu customerName (alfabetycznie od A do Z). Stwórz listę 5 obiektów klasy Order i posortuj ją zgodnie z oboma kryteriami (najpierw po dacie zamówienia, a następnie po nazwie klienta).\nNapisz klasę Song z polami title (typu String), artist (typu String) oraz duration (typu int). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: DurationComparator do porównywania obiektów po polu duration (od najkrótszej do najdłuższej piosenki) oraz ArtistTitleComparator do porównywania obiektów po polu artist (alfabetycznie od A do Z) i w przypadku równości po polu title. Stwórz tablicę 5 obiektów klasy Song i posortuj ją zgodnie z oboma kryteriami (najpierw po długości utworu,a następnie po artyście i tytule).\nNapisz klasę Student z polami id (typu int), name (typu String) oraz averageGrade (typu double). Zaimplementuj dwie klasy implementujące generyczny interfejs Comparator: AverageGradeComparator do porównywania obiektów po polu averageGrade (od najwyższej do najniższej średniej ocen) oraz IdComparator do porównywania obiektów po polu id (od najniższego do najwyższego identyfikatora). Stwórz listę 5 obiektów klasy Student i posortuj ją zgodnie z oboma kryteriami (najpierw po średniej ocen, a następnie po identyfikatorze)."
  },
  {
    "objectID": "kopiowanie.html",
    "href": "kopiowanie.html",
    "title": "22  Kopiowanie obiektów",
    "section": "",
    "text": "Napisz klasę Student z trzema polami: name (String), age (int) i grade (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Student, sklonuj go, a następnie zmień ocenę (grade) oryginalnego studenta. Wyświetl oceny obu studentów, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z trzema polami: name (String), subject (String) i experience (int). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień doświadczenie (experience) oryginalnego nauczyciela. Wyświetl doświadczenie obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Car z trzema polami: make (String), model (String) i mileage (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Car, sklonuj go, a następnie zmień przebieg (mileage) oryginalnego samochodu. Wyświetl przebieg obu samochodów, aby zobaczyć, czy są niezależne.\nNapisz klasę Smartphone z trzema polami: brand (String), model (String) i productionDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Smartphone, sklonuj go, a następnie zmień datę produkcji oryginalnego smartfona. Wyświetl datę produkcji obu smartfonów, aby zobaczyć, czy są niezależne.\nNapisz klasę Laptop z trzema polami: brand (String), model (String) i purchaseDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Laptop, sklonuj go, a następnie zmień datę zakupu (purchaseDate) oryginalnego laptopa. Wyświetl datę zakupu obu laptopów, aby zobaczyć, czy są niezależne.\nNapisz klasę VideoGame z trzema polami: title (String), genre (String) i releaseDate (typu Date). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt VideoGame, sklonuj go, a następnie zmień datę wydania (releaseDate) oryginalnej gry. Wyświetl datę wydania obu gier, aby zobaczyć, czy są niezależne.\nNapisz klasę CreditCard z trzema polami: cardNumber (String), holderName (String) i expiryDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt CreditCard, sklonuj go, a następnie zmień datę wygaśnięcia (expiryDate) oryginalnej karty kredytowej. Wyświetl datę wygaśnięcia obu kart, aby zobaczyć, czy są niezależne.\nNapisz klasę BankAccount z trzema polami: accountNumber (String), accountHolder (String) i openingDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt BankAccount, sklonuj go, a następnie zmień datę otwarcia (openingDate) oryginalnego konta bankowego. Wyświetl datę otwarcia obu kont, aby zobaczyć, czy są niezależne.\nNapisz klasę DrivingLicense z trzema polami: licenseNumber (String), holderName (String) i issueDate (typu LocalDate). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt DrivingLicense, sklonuj go, a następnie zmień datę wydania (issueDate) oryginalnego prawa jazdy. Wyświetl datę wydania obu praw jazdy, aby zobaczyć, czy są niezależne.\nNapisz klasę Employee z dwoma polami: name (String) i salaries (tablica 12 zmiennych typu double, reprezentująca zarobki za każdy miesiąc). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Employee, sklonuj go, a następnie zmień zarobki na pozycji 5 (czerwiec) oryginalnego pracownika. Wyświetl zarobki obu pracowników, aby zobaczyć, czy są niezależne.\nNapisz klasę Athlete z dwoma polami: name (String) i times (tablica 5 zmiennych typu double, reprezentująca czas w sekundach potrzebny na przebiegnięcie 100 metrów podczas różnych prób). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Athlete, sklonuj go, a następnie zmień czas na pozycji 3 oryginalnego sportowca. Wyświetl czasy obu sportowców, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z dwoma polami: name (String) i studentsGrades (tablica 10 zmiennych typu double, reprezentująca oceny każdego z 10 uczniów). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień ocenę na pozycji 10 oryginalnego nauczyciela. Wyświetl oceny obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Employee z dwoma polami: name (String) i monthlyHours (lista tablicowa zmiennych typu int, reprezentująca liczbę przepracowanych godzin w każdym miesiącu). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Employee, sklonuj go, a następnie zmień liczbę godzin na pozycji 5 (czerwiec) oryginalnego pracownika. Wyświetl liczbę godzin obu pracowników, aby zobaczyć, czy są niezależne.\nNapisz klasę Athlete z dwoma polami: name (String) i lapTimes (lista tablicowa zmiennych typu int, reprezentująca czas w sekundach potrzebny na przebiegnięcie okrążenia podczas różnych prób). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Athlete, sklonuj go, a następnie zmień czas na pozycji 3 oryginalnego sportowca. Wyświetl czasy obu sportowców, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z dwoma polami: name (String) i studentsGrades (lista tablicowa zmiennych typu int, reprezentująca oceny każdego z uczniów). Zaimplementuj interfejs Cloneable i nadpisz metodę clone(), aby móc klonować obiekty tej klasy. W metodzie main() utwórz obiekt Teacher, sklonuj go, a następnie zmień ocenę na pozycji 10 oryginalnego nauczyciela. Wyświetl oceny obu nauczycieli, aby zobaczyć, czy są niezależne.\nNapisz klasę Teacher z polami name (String), age (int) i salary (double). Następnie napisz klasę HeadTeacher, która dziedziczy po klasie Teacher i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas.\nNapisz klasę Developer z polami name (String), age (int) i salary (double). Następnie napisz klasę SeniorDeveloper, która dziedziczy po klasie Developer i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas.\nNapisz klasę Nurse z polami name (String), age (int) i salary (double). Następnie napisz klasę HeadNurse, która dziedziczy po klasie Nurse i dodaje pole bonus (double). Zaimplementuj interfejs Cloneable i nadpisz metodę clone() w obu klasach. W metodzie main() pokaż przykład prezentujący poprawność klonowania obiektów tych klas."
  },
  {
    "objectID": "interfejsy.html",
    "href": "interfejsy.html",
    "title": "23  Interfejsy",
    "section": "",
    "text": "Napisz interfejs o nazwie LoudAnimal, który będzie miał jedną metodę o nazwie makeNoise(). Następnie stwórz dwie klasy: Dog i Cat, które będą implementować ten interfejs. Dla każdej klasy zaimplementuj metodę makeNoise(), tak aby wydrukowała ona odpowiedni dźwięk zwierzęcia.\nStwórz interfejs o nazwie MyComparator, który będzie zawierał metodę compare(int a, int b): int. Metoda ta powinna zwrócić -1, jeśli a &lt; b, 0 jeśli a == b i 1 jeśli a &gt; b. Następnie stwórz klasę TestMyComparator, która będzie implementować ten interfejs. W klasie tej zaimplementuj metodę compare zgodnie z jej opisem.\nZałóżmy, że mamy interfejs MusicPlayer z metodami turnOn(), turnOff() i nextTrack(). Stwórz klasę Radio, która będzie implementować ten interfejs. W metodzie turnOn() powinien zostać wydrukowany komunikat “Radio włączone”, w metodzie turnOff() - “Radio wyłączone”, a w nextTrack() - “Zmieniono stację radiową”.\nNapisz interfejs Converter z trzema abstrakcyjnymi metodami: convertToEuro(double amount) zwracającą double, convertToUSD(double amount) zwracającą double oraz getConversionRate(String currency) przyjmującą nazwę waluty jako String i zwracającą double. Stwórz dwie klasy: CurrencyConverter i UnitConverter, które implementują ten interfejs. W osobnej klasie ConverterTest, przetestuj implementację metod dla obiektów obu klas.\nUtwórz interfejs Authentication z trzema metodami abstrakcyjnymi: login(String username, String password) zwracającą boolean, logout() zwracającą void oraz resetPassword(String username, String oldPassword, String newPassword) zwracającą boolean. Stwórz dwie klasy UserAuthentication i AdminAuthentication, które implementują ten interfejs. W klasie AuthenticationTest przetestuj implementacje metod dla obiektów obu klas.\nZaprojektuj interfejs Sensor z trzema metodami abstrakcyjnymi: readValue() zwracającą double, getStatus() zwracającą String oraz reset() zwracającą void. Stwórz dwie klasy TemperatureSensor i PressureSensor, które implementują ten interfejs. W klasie SensorTest przetestuj działanie metod dla obiektów z obu klas.\nOpracuj interfejs MediaPlayer z trzema abstrakcyjnymi metodami: play(String trackName) zwracającą void, pause() zwracającą void oraz getCurrentTrack() zwracającą String. Stwórz dwie klasy AudioPlayer i VideoPlayer, które implementują ten interfejs. W osobnej klasie MediaPlayerTest sprawdź działanie metod dla obiektów z obu klas.\nStwórz interfejs Storage z trzema metodami abstrakcyjnymi: save(String data) zwracającą boolean, delete(String identifier) zwracającą boolean oraz retrieve(String identifier) zwracającą String. Zaprojektuj dwie klasy FileStorage i DatabaseStorage, które implementują ten interfejs. W klasie StorageTest wykonaj testy metod dla obiektów z obu klas.\nWykonaj poniższe czynności:\n\n\nNapisz interfejs DataProcessor z dwoma metodami abstrakcyjnymi: processData(String data) zwracającą String i isValid(String data) zwracającą boolean.\nStwórz klasę TextProcessor, która implementuje DataProcessor. W metodzie processData zwróć dane w odwróconej kolejności, a w metodzie isValid sprawdź, czy dane nie są pustym napisem. Zabezpiecz metody przed nullem.\nStwórz drugą klasę NumberProcessor, która również implementuje DataProcessor. W metodzie processData zwróć dane z dodatkowym tekstem na początku “Processed:”, a w metodzie isValid sprawdź, czy dane są liczbą.\nW klasie TestDataProcessor stwórz obiekty obu klas i przetestuj ich metody.\n\nWskazówka: W celu sprawdzenia, że string jest liczbą możesz użyć wyrażenia regularne:\nstr.matches(\"-?\\\\d+(\\\\.\\\\d+)?\")\n\nWykonaj poniższe czynności:\n\n\nUtwórz interfejs VehicleManager z dwoma metodami abstrakcyjnymi: startEngine() zwracającą String i getFuelLevel() zwracającą int.\nStwórz klasę Car, implementującą VehicleManager. W metodzie startEngine zwróć “Silnik samochodu uruchomiony”, a w getFuelLevel zwróć wartość 50.\nStwórz klasę Motorcycle, również implementującą VehicleManager. W startEngine zwróć “Silnik motocykla uruchomiony”, a w getFuelLevel zwróć wartość 30.\nW klasie VehicleManagerTest stwórz obiekty obu klas i przetestuj ich metody.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs AnimalSound z jedną metodą makeSound().\nRozszerz ten interfejs, tworząc interfejs DomesticAnimalSound, który dodaje metodę makeHappySound().\nStwórz klasę Dog, która implementuje DomesticAnimalSound. Metoda makeSound() powinna zwracać string “Woof”, a makeHappySound() - “Wag tail”.\nW osobnej klasie testującej (TestAnimals), utwórz obiekt Dog i wywołaj obie metody.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs PowerControl z metodą turnOn().\nRozszerz ten interfejs, tworząc AdvancedPowerControl, który dodaje metodę setPowerSavingMode().\nStwórz klasę SmartLamp, implementującą AdvancedPowerControl. Metoda turnOn() powinna aktywować lampę, a setPowerSavingMode() - przełączać ją w tryb oszczędzania energii (metody mają wyświetlać odpowiednie komunikaty).\nW osobnej klasie testującej (TestDevices), utwórz obiekt SmartLamp i wywołaj obie metody.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs Drawable z metodą draw().\nRozszerz ten interfejs, tworząc ColorDrawable, który dodaje metodę setColor(String color).\nStwórz klasę Circle, implementującą ColorDrawable. Metoda draw() powinna rysować koło, a setColor() - zmieniać kolor koła (metody mają wyświetlać odpowiednie komunikaty).\nW osobnej klasie testującej (TestDrawing), utwórz obiekt Circle, ustaw kolor i narysuj koło za pomocą obu metod.\n\n\nStwórz interfejs Drawable z:\n\n\nMetodą abstrakcyjną draw().\nMetodą domyślną display() wyświetlającą informację “Displaying Drawable”.\nMetodą statyczną getType() zwracającą String “Drawable Type”.\n\nStwórz klasy Circle i Rectangle, które implementują Drawable. draw() w Circle powinno wyświetlać “Drawing Circle”, a w Rectangle - “Drawing Rectangle”. Stwórz klasę testującą DrawableTester. Utwórz obiekty Circle i Rectangle, wywołaj dla nich draw() i display(), oraz statycznie Drawable.getType().\n\nStwórz interfejs SoundPlayer z:\n\n\nMetodą abstrakcyjną playSound().\nMetodą domyślną stopSound() wyświetlającą informację “Sound Stopped”.\nMetodą statyczną getDeviceType() zwracającą String “Sound Device”.\n\nStwórz klasy MusicPlayer i Radio, które implementują SoundPlayer. playSound() w MusicPlayer powinno wyświetlać “Playing Music”, a w Radio - “Playing Radio”. Stwórz klasę testującą SoundTester. Utwórz obiekty MusicPlayer i Radio, wywołaj dla nich playSound() i stopSound(), oraz statycznie SoundPlayer.getDeviceType().\n\nStwórz interfejs MemoryManager z:\n\n\nMetodą abstrakcyjną allocateMemory(int size).\nMetodą domyślną freeMemory() wyświetlającą informację “Memory Freed”.\nMetodą statyczną getMemoryType() zwracającą String “Memory Type”.\n\nStwórz klasy RAMManager i DiskManager, które implementują MemoryManager. allocateMemory(int size) w RAMManager powinno wyświetlać “Allocating RAM Memory”, a w DiskManager - “Allocating Disk Space”. Stwórz klasę testującą MemoryTester. Utwórz obiekty RAMManager i DiskManager, wywołaj dla nich allocateMemory(int size) i freeMemory(), oraz statycznie MemoryManager.getMemoryType().\n\nStwórz interfejs VATCalculator z:\n\n\nPolem double vatRate ustawionym na wartość standardowej stawki VAT (np. 23%).\nMetodą statyczną calculateWithVAT(double price), która oblicza i zwraca cenę produktu z doliczonym VAT.\n\nStwórz klasę testującą VATTest, która wywołuje metodę calculateWithVAT(double price) z przykładową ceną produktu i wyświetla wynik."
  },
  {
    "objectID": "delegacje.html",
    "href": "delegacje.html",
    "title": "24  Delegacje",
    "section": "",
    "text": "Wykonaj poniższe czynności:\n\n\nStwórz interfejs Printer z metodą drukuj(String tekst).\nUtwórz klasę StandardowyPrinter, która implementuje Printer i wypisuje tekst na konsolę.\nUtwórz klasę Biuro, która posiada prywatne pole typu Printer. W konstruktorze Biuro przyjmij Printer jako argument i przypisz go do pola. Dodaj metodę drukujDokument(String tekst), która będzie delegować zadanie drukowania do obiektu klasy Printer.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs Silnik z metodami uruchom() i zatrzymaj().\nUtwórz klasę BenzynowySilnik, która implementuje Silnik i symuluje działanie silnika na benzynę.\nUtwórz klasę Samochód, która posiada prywatne pole typu Silnik. W konstruktorze przyjmij Silnik jako argument. Dodaj metody start() i stop(), które będą delegować odpowiednio zadanie uruchomienia i zatrzymania silnika do obiektu klasy Silnik.\n\n\nWykonaj poniższe czynności:\n\n\nStwórz interfejs Powiadomienie z metodą wyślij(String wiadomość).\nUtwórz klasę Email, która implementuje Powiadomienie i symuluje wysyłanie wiadomości e-mail.\nUtwórz klasę Użytkownik, która posiada prywatne pole typu Powiadomienie. W konstruktorze przyjmij Powiadomienie jako argument. Dodaj metodę powiadomOModernizacji(String informacja), która będzie delegować zadanie wysyłania powiadomienia do obiektu klasy Powiadomienie."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliografia i inne zbiory zadań",
    "section": "",
    "text": "Kozak, Jan. n.d. Materiały Do Ćwiczeń. Accessed July 16, 2023.\nhttp://www.jkozak.pl/przedmioty/podstawy-i-jezyki-programowania/materialy-do-cwiczen/.\n\n\nRychlicki, Wiesław. 2012. Programowanie w Języku Java. Zbiór Zadań z\n(p)odpowiedziami. Helion."
  }
]